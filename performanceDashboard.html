<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="STELVIO AI - Performance Dashboard">
  <title>STELVIO AI - Performance Dashboard</title>
  
  <!-- Tailwind / Babel CDN 경고 필터 (반드시 최상단, CDN 로드 전) -->
  <script>
    (function() {
      if (typeof console === 'undefined' || !console.warn) return;
      var orig = console.warn;
      console.warn = function() {
        var msg = (arguments[0] && String(arguments[0])) || '';
        if (msg.indexOf('cdn.tailwindcss.com') !== -1 || msg.indexOf('Tailwind CSS') !== -1 && msg.indexOf('production') !== -1 ||
            msg.indexOf('in-browser Babel') !== -1 || msg.indexOf('precompile your scripts') !== -1 || (msg.indexOf('Babel') !== -1 && msg.indexOf('production') !== -1)) {
          return;
        }
        return orig.apply(console, arguments);
      };
    })();
  </script>
  
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React & ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone (JSX 변환용) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Chart.js (차트 라이브러리) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
  <script src="assets/js/firebaseConfig.js"></script>
  
  <!-- 프로젝트 스크립트 (assets/js/) -->
  <script src="assets/js/trainingManager.js"></script>
  <script src="assets/js/stravaManager.js"></script>
  <script src="assets/js/userManager.js"></script>
  
  <!-- Dashboard 전용: Firebase Standalone Fallback (iOS Bluefy 호환) -->
  <script>
    // Firebase 독립 초기화 함수 (부모 창 의존성 제거)
    window.initFirebaseStandalone = function() {
      if (typeof firebase === 'undefined') {
        console.warn('[Dashboard] Firebase SDK가 아직 로드되지 않음');
        return null;
      }
      
      try {
        // Firebase 설정 (firebaseConfig.js와 동일)
        var firebaseConfig = {
          apiKey: "AIzaSyDVQJZV6NIbqhPdz1CKfbA8yHHYClSC35Q",
          authDomain: "stelvio-ai.firebaseapp.com",
          projectId: "stelvio-ai",
          storageBucket: "stelvio-ai.firebasestorage.app",
          messagingSenderId: "752285835508",
          appId: "1:752285835508:web:0662a24874209ebb483ea1",
          databaseURL: "https://stelvio-ai-default-rtdb.firebaseio.com"
        };
        
        // 이미 초기화되어 있는지 확인
        var app = null;
        try {
          app = firebase.app('dashboard-standalone');
          console.log('[Dashboard] 기존 Firebase 앱 인스턴스 사용');
        } catch (e) {
          // 'dashboard-standalone' 이름의 앱이 없으면 새로 생성
          try {
            app = firebase.initializeApp(firebaseConfig, 'dashboard-standalone');
            console.log('[Dashboard] Firebase 독립 초기화 성공 (dashboard-standalone)');
          } catch (initErr) {
            // 이미 기본 앱이 있으면 그것 사용
            if (firebase.apps.length > 0) {
              app = firebase.app();
              console.log('[Dashboard] 기본 Firebase 앱 사용');
            } else {
              throw initErr;
            }
          }
        }
        
        // Auth Persistence 설정 (iOS 필수) - await로 동기화
        var auth = null;
        if (app && firebase.auth) {
          try {
            auth = firebase.auth(app);
            // LOCAL persistence 설정 (세션 유지) - 동기적으로 설정 시도
            if (auth && auth.setPersistence) {
              // setPersistence는 Promise를 반환하지만, 여기서는 비동기로 처리
              // 호출하는 쪽에서 await로 처리하도록 함
            }
            window.auth = auth;
            console.log('[Dashboard] Auth 초기화 완료 (Standalone)');
          } catch (authErr) {
            console.warn('[Dashboard] Auth 초기화 실패:', authErr);
          }
        }
        
        // Firestore 초기화
        var firestore = null;
        if (app && firebase.firestore) {
          try {
            firestore = firebase.firestore(app);
            window.firestore = firestore;
            console.log('[Dashboard] Firestore 독립 초기화 성공');
          } catch (fsErr) {
            console.warn('[Dashboard] Firestore 초기화 실패:', fsErr);
          }
        }
        
        return { app: app, auth: window.auth, firestore: firestore };
      } catch (e) {
        console.error('[Dashboard] Firebase 독립 초기화 실패:', e);
        return null;
      }
    };
  </script>
  
  <!-- Dashboard 전용: Gemini 코치 프롬프트 및 API (인라인, 404 방지) -->
  <script>
    window.GEMINI_COACH_SYSTEM_PROMPT = `Role: 당신은 'Stelvio AI'의 수석 사이클링 코치이자 데이터 분석가입니다.
Context: 사용자의 프로필({{userProfile}})과 최근 30일간의 훈련 로그({{recentLogs}})를 분석하여 JSON 형식으로 인사이트를 제공해야 합니다.

[데이터 출처]
- userProfile: Firestore users/{userId} 컬렉션 (id, name, ftp, weight, grade, challenge, acc_points, rem_points 등)
- recentLogs: Firestore users/{userId}/logs 서브컬렉션 (최근 30일, source='strava' 또는 source 없음)
  * 로그 필드: activity_id, date, title, distance_km, time, duration_sec, tss, user_id, source 등
  * 최대 30개, 날짜 내림차순 정렬
Task Requirements:
1. **Condition Score (0~100):** TSB(Training Stress Balance)와 최근 운동 강도를 기반으로 컨디션 점수를 산출하세요.
2. **Training Status:** 현재 상태를 한 단어로 정의하세요 (예: "Ready to Race", "Recovery Needed", "Building Base", "Peaking").
3. **Coach Comment:** 사용자의 이름({{userName}})을 부르며, 최근 훈련 성과(FTP 변화, TSS 누적 등)를 언급하고 동기를 부여하는 따뜻한 조언을 한국어(경어체)로 한 문장 작성하세요.
4. **VO2max Estimate:** 파워 데이터를 기반으로 추정된 VO2max 값을 정수로 반환하세요.
5. **Recommended Workout:** 오늘 수행해야 할 추천 훈련 타입을 제안하세요.
Output Format (JSON Only):
{ "condition_score": 85, "training_status": "Ready to Race", "vo2max_estimate": 54, "coach_comment": "지성님, 이번 주 TSS 목표를 거의 달성하셨네요! 오늘은 가벼운 리커버리로 컨디션을 조절하세요.", "recommended_workout": "Active Recovery (Z1)" }`;
    function isMobile() {
      var ua = navigator.userAgent || '';
      var isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
      var isTouchDevice = (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) || ('ontouchstart' in window);
      var isBluefy = /Bluefy/i.test(ua) || (window.navigator && window.navigator.standalone === false && window.navigator.standalone !== undefined);
      return isMobileUA || isTouchDevice || isBluefy;
    }
    async function callGeminiCoach(userProfile, recentLogs) {
      var apiKey;
      try {
        apiKey = localStorage.getItem('geminiApiKey');
      } catch (e) {
        apiKey = null;
      }
      if (!apiKey) throw new Error('Gemini API 키가 설정되지 않았습니다. 환경 설정에서 API 키를 입력해주세요.');
      var prompt = (window.GEMINI_COACH_SYSTEM_PROMPT || '')
        .replace('{{userProfile}}', JSON.stringify(userProfile, null, 2))
        .replace('{{recentLogs}}', JSON.stringify(recentLogs || [], null, 2))
        .replace('{{userName}}', (userProfile && userProfile.name) || '사용자');
      var modelName = localStorage.getItem('geminiModelName') || 'gemini-2.5-flash';
      var apiVersion = localStorage.getItem('geminiApiVersion') || 'v1beta';
      var url = 'https://generativelanguage.googleapis.com/' + apiVersion + '/models/' + modelName + ':generateContent?key=' + apiKey;
      var generationConfig = {
        maxOutputTokens: 10000, // 충분한 토큰으로 시작하여 MAX_TOKENS 오류 방지 및 속도 향상
        temperature: 0.7,
        topP: 0.8,
        topK: 40
      };
      // gemini-2.5-pro는 thinking 모드가 필수이므로 thinkingConfig를 추가하지 않음
      // 다른 모델(예: gemini-2.5-flash)은 thinking을 비활성화하여 parts[0]이 텍스트가 되도록 함
      if (modelName.indexOf('pro') === -1 && modelName.indexOf('thinking') === -1) {
        generationConfig.thinkingConfig = { thinkingBudget: 0 };
      }
      var body = {
        contents: [{ parts: [{ text: prompt }] }],
        generationConfig: generationConfig
      };
      var timeoutMs = isMobile() ? 45000 : 25000;
      var lastErr = null;
      var hasAbortController = typeof AbortController !== 'undefined';
      for (var attempt = 0; attempt < 3; attempt++) {
        try {
          var controller = null;
          var timeoutId = null;
          var wasAborted = false;
          var fetchOptions = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) };
          if (hasAbortController) {
            try {
              controller = new AbortController();
              timeoutId = setTimeout(function() {
                if (controller) {
                  wasAborted = true;
                  controller.abort();
                }
              }, timeoutMs);
              fetchOptions.signal = controller.signal;
            } catch (e) {
              hasAbortController = false;
            }
          }
          var fetchPromise = fetch(url, fetchOptions).catch(function(fetchErr) {
            var errMsg = fetchErr && fetchErr.message ? fetchErr.message : String(fetchErr);
            var isAbort = wasAborted || (fetchErr && fetchErr.name === 'AbortError');
            console.error('[callGeminiCoach] fetch 실패 (시도 ' + (attempt + 1) + '):', {
              error: errMsg,
              isAborted: isAbort,
              url: url.substring(0, 100) + '...',
              timeoutMs: timeoutMs
            });
            if (isAbort) {
              throw new Error('요청 시간 초과 (' + timeoutMs + 'ms)');
            }
            throw fetchErr;
          });
          var timeoutPromise = hasAbortController ? null : new Promise(function(resolve, reject) {
            timeoutId = setTimeout(function() { reject(new Error('요청 시간 초과')); }, timeoutMs);
          });
          var res;
          try {
            res = hasAbortController ? await fetchPromise : await Promise.race([fetchPromise, timeoutPromise]);
          } catch (fetchErr) {
            if (timeoutId) clearTimeout(timeoutId);
            var errMsg = fetchErr && fetchErr.message ? fetchErr.message : String(fetchErr);
            if (errMsg.indexOf('Failed to fetch') !== -1 && !wasAborted) {
              // Failed to fetch는 네트워크 문제일 수 있음
              throw new Error('네트워크 오류: 인터넷 연결을 확인하거나, 방화벽/보안 소프트웨어가 API 요청을 차단했을 수 있습니다.');
            }
            throw fetchErr;
          }
          if (timeoutId) clearTimeout(timeoutId);
          
          if (!res.ok) {
            var errBody = await res.text();
            var errMsg = '';
            try {
              var ed = JSON.parse(errBody);
              errMsg = (ed.error && ed.error.message) || errBody;
            } catch (e2) { errMsg = errBody.substring(0, 200); }
            throw new Error('Gemini API 오류 (' + res.status + '): ' + errMsg);
          }
          
          var data = await res.json();
          if (!data || !data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
            throw new Error('Gemini API 응답에 candidates가 없습니다.');
          }
          var candidate = data.candidates[0];
          if (candidate.finishReason === 'SAFETY') {
            throw new Error('Gemini API가 안전 정책으로 응답을 차단했습니다.');
          }
          var parts = candidate.content && candidate.content.parts ? candidate.content.parts : [];
          // MAX_TOKENS인 경우 maxOutputTokens를 증가시켜 재시도 (안전장치, 초기값 10000이면 거의 발생하지 않음)
          if (candidate.finishReason === 'MAX_TOKENS' && (!parts.length || !parts.find(function(p) { return p && p.text && p.text.trim(); }))) {
            if (attempt < 2) {
              // 이미 10000이면 20000으로 증가 (최대 32000까지)
              generationConfig.maxOutputTokens = Math.min(32000, generationConfig.maxOutputTokens < 10000 ? 10000 : generationConfig.maxOutputTokens * 2);
              body.generationConfig = generationConfig;
              console.warn('[callGeminiCoach] MAX_TOKENS 도달, maxOutputTokens 증가:', generationConfig.maxOutputTokens);
              throw new Error('MAX_TOKENS - 재시도');
            } else {
              throw new Error('Gemini API 응답이 토큰 제한에 도달했습니다. (MAX_TOKENS)');
            }
          }
          if (!parts.length) {
            console.error('[callGeminiCoach] content.parts 없음:', {
              finishReason: candidate.finishReason,
              hasContent: !!candidate.content,
              partsLength: parts.length,
              candidate: JSON.stringify(candidate).substring(0, 500)
            });
            throw new Error('Gemini API 응답에 content.parts가 없습니다.');
          }
          var text = '';
          for (var i = 0; i < parts.length; i++) {
            if (parts[i] && typeof parts[i].text === 'string' && parts[i].text.trim()) {
              text = parts[i].text.trim();
              break;
            }
          }
          if (!text) {
            console.error('[callGeminiCoach] text가 있는 part 없음:', { finishReason: candidate.finishReason, partsLength: parts.length });
            throw new Error('Gemini API 응답이 비어있습니다.');
          }
          if (text.indexOf('```') === 0) {
            text = text.replace(/^```(?:json)?\s*/i, '').replace(/\s*```$/i, '');
          }
          var result = JSON.parse(text);
          return {
            condition_score: (typeof result.condition_score === 'number') ? Math.max(0, Math.min(100, result.condition_score)) : 50,
            training_status: result.training_status || 'Building Base',
            vo2max_estimate: (typeof result.vo2max_estimate === 'number') ? Math.max(20, Math.min(100, result.vo2max_estimate)) : 40,
            coach_comment: result.coach_comment || ((userProfile && userProfile.name) || '사용자') + '님, 오늘도 화이팅하세요!',
            recommended_workout: result.recommended_workout || 'Active Recovery (Z1)'
          };
        } catch (e) {
          lastErr = e;
          var errType = 'unknown';
          var errDetail = '';
          var isMaxTokens = false;
          if (e && e.message) {
            errType = e.message;
            if (e.message.indexOf('MAX_TOKENS') !== -1 || (e.message.indexOf('재시도') !== -1 && e.message.indexOf('MAX_TOKENS') === -1)) {
              isMaxTokens = true;
              errType = 'MAX_TOKENS';
              errDetail = '응답이 토큰 제한에 도달했습니다. maxOutputTokens를 증가시켜 재시도합니다.';
            } else if (e.message.indexOf('네트워크 오류') !== -1 || e.message.indexOf('Failed to fetch') !== -1 || e.message.indexOf('NetworkError') !== -1) {
              errType = '네트워크 오류';
              errDetail = '인터넷 연결을 확인하거나, 방화벽/보안 소프트웨어가 API 요청을 차단했을 수 있습니다.';
              if (window.parent && window.parent !== window) {
                errDetail += ' (iframe 환경에서는 일부 브라우저에서 외부 API 호출이 제한될 수 있습니다)';
              }
            } else if (e.message.indexOf('CORS') !== -1 || e.message.indexOf('cross-origin') !== -1) {
              errType = 'CORS 오류';
              errDetail = '브라우저 보안 정책으로 인해 API 호출이 차단되었습니다.';
            } else if (e.message.indexOf('aborted') !== -1 || e.message.indexOf('시간 초과') !== -1 || e.message.indexOf('AbortError') !== -1) {
              errType = '요청 시간 초과';
              errDetail = '네트워크가 느리거나 서버 응답이 지연되고 있습니다.';
            }
          }
          if (attempt < 2) {
            console.warn('[callGeminiCoach] 재시도 ' + (attempt + 1) + '/3:', errType, errDetail || '');
            // MAX_TOKENS인 경우 즉시 재시도
            // 네트워크 오류는 3초 대기 (연결 복구 시간 확보)
            // 다른 오류는 2초 대기
            if (isMaxTokens) {
              // 즉시 재시도
            } else if (errType === '네트워크 오류' || errType === '요청 시간 초과') {
              await new Promise(function(r) { setTimeout(r, 3000); });
            } else {
              await new Promise(function(r) { setTimeout(r, 2000); });
            }
          }
        }
      }
      var errMsg = lastErr && lastErr.message ? lastErr.message : 'unknown';
      var errDisplay = errMsg;
      if (errMsg.indexOf('Failed to fetch') !== -1) {
        errDisplay = '네트워크 오류: 인터넷 연결을 확인하거나, 방화벽이 API 요청을 차단했을 수 있습니다.';
        if (window.parent && window.parent !== window) {
          errDisplay += ' (iframe 환경 제한 가능)';
        }
      }
      console.warn('[callGeminiCoach] AI 분석 실패 (재시도 3회 후):', errMsg);
      if (lastErr && lastErr.stack) {
        console.error('[callGeminiCoach] 오류 스택:', lastErr.stack.substring(0, 500));
      }
      return {
        condition_score: 50,
        training_status: 'Building Base',
        vo2max_estimate: 40,
        coach_comment: ((userProfile && userProfile.name) || '사용자') + '님, 데이터 분석 중 일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
        recommended_workout: 'Active Recovery (Z1)',
        error_reason: errDisplay || errMsg
      };
    }
    window.callGeminiCoach = callGeminiCoach;
  </script>
  
  <style>
    /* 스크롤바 숨김 - 전체(html/body) 및 .scrollbar-hide */
    html, body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar {
      display: none;
    }
    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }
    
    /* Circular Progress Bar 애니메이션 */
    @keyframes progress {
      from {
        stroke-dashoffset: 283;
      }
    }
    
    .circular-progress {
      animation: progress 1s ease-out;
    }
    
    /* Skeleton UI 애니메이션 */
    @keyframes shimmer {
      0% {
        background-position: -1000px 0;
      }
      100% {
        background-position: 1000px 0;
      }
    }
    
    .skeleton {
      background: linear-gradient(
        90deg,
        #f0f0f0 0px,
        #e0e0e0 40px,
        #f0f0f0 80px
      );
      background-size: 1000px;
      animation: shimmer 2s infinite;
    }
  </style>
</head>
<body class="bg-gray-50 scrollbar-hide">
  <script>
    window.__dashboardUserFromParent = null;
    window.addEventListener('message', function (e) {
      try {
        if (e.data && e.data.type === 'DASHBOARD_USER' && e.data.user) {
          if (window.parent && window.parent !== window) {
            var origin = e.origin || '';
            var parentOrigin = window.location.origin || '';
            if (origin === parentOrigin || origin === '*' || parentOrigin === '') {
              window.__dashboardUserFromParent = e.data.user;
            }
          } else {
            window.__dashboardUserFromParent = e.data.user;
          }
        }
      } catch (err) {
        console.warn('[Dashboard] postMessage 처리 오류:', err);
      }
    });
  </script>
  <div id="dashboard-root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // 포인트 포맷팅 유틸리티 (정수, 1000 이상은 k 형식)
    function formatPoints(points) {
      const num = Math.round(Number(points) || 0);
      if (num >= 1000) {
        const k = num / 1000;
        return k % 1 === 0 ? k + 'k' : k.toFixed(1) + 'k';
      }
      return num.toString();
    }
    
    // DashboardCard 컴포넌트
    function DashboardCard({ title, children, className = "" }) {
      return (
        <div className={`bg-white rounded-2xl p-4 shadow-sm border border-gray-100 ${className}`}>
          {title && (
            <h3 className="text-sm font-semibold text-gray-600 mb-3">{title}</h3>
          )}
          {children}
        </div>
      );
    }
    
    // Training Trend Chart 컴포넌트 (Chart.js 사용)
    function TrainingTrendChart({ data }) {
      const chartRef = useRef(null);
      const chartInstanceRef = useRef(null);
      
      useEffect(() => {
        if (!data || data.length === 0) return;
        
        const ctx = chartRef.current?.getContext('2d');
        if (!ctx) return;
        
        // 기존 차트가 있으면 제거
        if (chartInstanceRef.current) {
          chartInstanceRef.current.destroy();
        }
        
        // Chart.js로 차트 생성
        chartInstanceRef.current = new Chart(ctx, {
          type: 'line',
          data: {
            labels: data.map(d => d.date),
            datasets: [
              {
                label: 'Fitness',
                data: data.map(d => d.fitness),
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                tension: 0.4,
                fill: false,
                pointRadius: 4,
                pointBackgroundColor: '#3b82f6'
              },
              {
                label: 'Fatigue',
                data: data.map(d => d.fatigue),
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                tension: 0.4,
                fill: false,
                pointRadius: 4,
                pointBackgroundColor: '#ef4444'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: {
                  usePointStyle: true,
                  padding: 15,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                backgroundColor: 'white',
                borderColor: '#e5e7eb',
                borderWidth: 1,
                cornerRadius: 8,
                padding: 12,
                titleFont: {
                  size: 13,
                  weight: 'bold'
                },
                bodyFont: {
                  size: 12
                }
              }
            },
            scales: {
              x: {
                grid: {
                  display: true,
                  color: '#e5e7eb',
                  drawBorder: false
                },
                ticks: {
                  font: {
                    size: 11
                  },
                  color: '#6b7280'
                }
              },
              y: {
                grid: {
                  display: true,
                  color: '#e5e7eb',
                  drawBorder: false
                },
                ticks: {
                  font: {
                    size: 11
                  },
                  color: '#6b7280'
                },
                beginAtZero: true
              }
            }
          }
        });
        
        // 컴포넌트 언마운트 시 차트 정리
        return () => {
          if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
            chartInstanceRef.current = null;
          }
        };
      }, [data]);
      
      if (!data || data.length === 0) {
        return (
          <DashboardCard title="훈련 트렌드 (최근 7일)">
            <div className="h-[200px] flex items-center justify-center text-gray-400 text-sm">
              데이터가 없습니다
            </div>
          </DashboardCard>
        );
      }
      
      return (
        <DashboardCard title="훈련 트렌드 (최근 7일)">
          <div className="h-[200px]">
            <canvas ref={chartRef}></canvas>
          </div>
        </DashboardCard>
      );
    }
    
    // Circular Progress 컴포넌트
    function CircularProgress({ value, max = 100, size = 120, strokeWidth = 8 }) {
      const percentage = Math.min((value / max) * 100, 100);
      const radius = (size - strokeWidth) / 2;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percentage / 100) * circumference;
      
      const getColor = () => {
        if (percentage >= 80) return '#10b981'; // green
        if (percentage >= 60) return '#3b82f6'; // blue
        if (percentage >= 40) return '#f59e0b'; // amber
        return '#ef4444'; // red
      };
      
      return (
        <div className="relative inline-flex items-center justify-center" style={{ width: size, height: size }}>
          <svg width={size} height={size} className="transform -rotate-90">
            {/* 배경 원 */}
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              stroke="#e5e7eb"
              strokeWidth={strokeWidth}
              fill="none"
            />
            {/* 진행 원 */}
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              stroke={getColor()}
              strokeWidth={strokeWidth}
              fill="none"
              strokeDasharray={circumference}
              strokeDashoffset={offset}
              strokeLinecap="round"
              className="circular-progress transition-all duration-500"
            />
          </svg>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center">
              <div className="text-3xl font-bold" style={{ color: getColor() }}>
                {Math.round(value)}
              </div>
              <div className="text-xs text-gray-500">점</div>
            </div>
          </div>
        </div>
      );
    }
    
    // 메인 Dashboard 컴포넌트
    function PerformanceDashboard() {
      const [userProfile, setUserProfile] = useState(null);
      const [coachData, setCoachData] = useState(null);
      const [recentLogs, setRecentLogs] = useState([]);
      const [logsLoaded, setLogsLoaded] = useState(false);
      const [logsLoading, setLogsLoading] = useState(false); // 로그 로딩 상태 (로딩 중/실패/성공 구분)
      const [logsLoadError, setLogsLoadError] = useState(null); // 로그 로딩 실패 원인
      const [loading, setLoading] = useState(true);
      const [stats, setStats] = useState({
        ftp: 0,
        wkg: 0,
        weight: 0,
        totalPoints: 0,
        currentPoints: 0,
        weeklyGoal: 0,
        weeklyProgress: 0
      });
      const [aiPairingStatus, setAiPairingStatus] = useState(false);
      const [stravaStatus, setStravaStatus] = useState({ connected: false, lastSync: null });
      const [fitnessData, setFitnessData] = useState([]);
      const [retryCoach, setRetryCoach] = useState(0);
      
      // iOS Bluefy: 페이지 로드 시 즉시 Firebase Standalone 초기화 시도
      useEffect(function() {
        // Firebase SDK 로드 대기 후 즉시 Standalone Fallback 시도
        var initAttempts = 0;
        var maxInitAttempts = 10;
        var initInterval = setInterval(function() {
          initAttempts++;
          if (typeof firebase !== 'undefined' && typeof window.initFirebaseStandalone === 'function') {
            clearInterval(initInterval);
            try {
              var standalone = window.initFirebaseStandalone();
              if (standalone && standalone.firestore) {
                window.firestore = standalone.firestore;
                if (standalone.auth) {
                  window.auth = standalone.auth;
                  // Auth Persistence 설정
                  if (standalone.auth.setPersistence) {
                    standalone.auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
                      .then(function() {
                        console.log('[Dashboard] 페이지 로드: Auth Persistence 설정 완료 (LOCAL) - iOS Bluefy');
                      })
                      .catch(function(e) {
                        console.warn('[Dashboard] 페이지 로드: Auth Persistence 설정 실패:', e);
                      });
                  }
                }
                console.log('[Dashboard] 페이지 로드: Firebase Standalone 초기화 성공');
              }
            } catch (e) {
              console.warn('[Dashboard] 페이지 로드: Firebase Standalone 초기화 실패:', e);
            }
          } else if (initAttempts >= maxInitAttempts) {
            clearInterval(initInterval);
            console.warn('[Dashboard] 페이지 로드: Firebase SDK 로드 타임아웃');
          }
        }, 500);
        
        return function() {
          clearInterval(initInterval);
        };
      }, []);
      
      // 사용자 프로필 로드: URL/postMessage/localStorage 즉시 표시, Firestore는 나중에 보강
      // AI 분석에 사용되는 userProfile 필드:
      // - id, name, ftp, weight, grade, challenge, acc_points, rem_points 등
      // - 출처: Firestore users/{userId} 컬렉션 또는 localStorage/postMessage
      useEffect(() => {
        function applyProfileFromUser(u) {
          const id = u.id || u.uid;
          const name = u.name || u.displayName || '사용자';
          const ftp = Number(u.ftp) || 0;
          const weight = Number(u.weight) || 0;
          const wkg = weight > 0 ? (ftp / weight).toFixed(2) : 0;
          setUserProfile({
            id: id,
            name: name,
            ftp: ftp,
            weight: weight,
            grade: u.grade || '2',
            challenge: u.challenge || 'Fitness',
            acc_points: u.acc_points || 0,
            rem_points: u.rem_points || 0,
            ...u
          });
          var challenge = u.challenge || 'Fitness';
          var weeklyTarget = 100;
          if (typeof window.getWeeklyTargetTSS === 'function') {
            var targetInfo = window.getWeeklyTargetTSS(challenge);
            weeklyTarget = targetInfo.target;
          }
          setStats({
            ftp: ftp,
            wkg: parseFloat(wkg),
            weight: weight,
            totalPoints: Number(u.acc_points || 0),
            currentPoints: Number(u.rem_points || 0),
            weeklyGoal: weeklyTarget,
            weeklyProgress: 0
          });
          setStravaStatus({
            connected: !!(u.strava_refresh_token),
            lastSync: u.strava_last_sync || null
          });
        }
        
        function phase1Immediate() {
          let userId = null;
          let fullUser = null;
          try {
            var search = window.location.search || '';
            if (search && typeof URLSearchParams !== 'undefined') {
              const params = new URLSearchParams(search);
              userId = params.get('userId') || params.get('user_id') || null;
            } else if (search) {
              var match = search.match(/[?&](?:userId|user_id)=([^&]+)/);
              if (match) userId = decodeURIComponent(match[1]);
            }
            if (userId) console.log('[Dashboard] URL에서 사용자 ID 가져옴:', userId);
          } catch (e) {
            console.warn('[Dashboard] URL 파라미터 파싱 실패:', e);
          }
          if (!userId && window.__dashboardUserFromParent && window.__dashboardUserFromParent.id) {
            fullUser = window.__dashboardUserFromParent;
            userId = fullUser.id;
            console.log('[Dashboard] postMessage에서 사용자 가져옴:', userId);
          }
          if (!fullUser) {
            try {
              const stored = localStorage.getItem('currentUser');
              if (stored) {
                const parsed = JSON.parse(stored);
                if (parsed && (parsed.id || parsed.uid)) {
                  fullUser = parsed;
                  userId = fullUser.id || fullUser.uid;
                  if (!userId) console.log('[Dashboard] localStorage에서 사용자 가져옴');
                }
              }
            } catch (e) {
              console.warn('[Dashboard] localStorage 사용자 조회 실패:', e);
            }
          }
          if (!userId && window.parent && window.parent !== window) {
            try {
              const auth = window.parent.auth || window.parent.window?.auth;
              const cu = auth && auth.currentUser;
              if (cu && cu.uid) {
                userId = cu.uid;
                console.log('[Dashboard] 부모 창 auth에서 사용자 ID 가져옴:', userId);
              }
            } catch (e) {}
          }
          if (!userId && window.auth) {
            try {
              const cu = window.auth.currentUser;
              if (cu && cu.uid) {
                userId = cu.uid;
                console.log('[Dashboard] 현재 창 auth에서 사용자 ID 가져옴:', userId);
              }
            } catch (e) {}
          }
          if (!userId) {
            console.warn('[Dashboard] 사용자 ID를 찾을 수 없습니다.');
            setUserProfile({ id: '', name: '사용자 선택 필요', ftp: 0, weight: 0, grade: '2', acc_points: 0, rem_points: 0 });
            setLoading(false);
            return null;
          }
          if (fullUser) {
            applyProfileFromUser(fullUser);
            setLoading(false);
          } else {
            applyProfileFromUser({ id: userId, name: '사용자', ftp: 0, weight: 0 });
            setLoading(false);
          }
          return userId;
        }
        
        async function phase2Firestore(userId) {
          // iOS Bluefy 호환: Auth Persistence 설정 (세션 유지) - 최우선 실행
          if (typeof firebase !== 'undefined' && firebase.auth) {
            try {
              var auth = window.auth;
              if (!auth) {
                // Standalone Fallback으로 Auth 가져오기
                if (typeof window.initFirebaseStandalone === 'function') {
                  var standalone = window.initFirebaseStandalone();
                  if (standalone && standalone.auth) {
                    auth = standalone.auth;
                    window.auth = auth;
                    console.log('[Dashboard] phase2Firestore: Standalone Auth 사용');
                  }
                }
                // 여전히 없으면 기본 auth 사용
                if (!auth && firebase.apps && firebase.apps.length > 0) {
                  try {
                    auth = firebase.auth();
                    window.auth = auth;
                    console.log('[Dashboard] phase2Firestore: 기본 Auth 사용');
                  } catch (authErr) {
                    console.warn('[Dashboard] phase2Firestore: 기본 Auth 초기화 실패:', authErr);
                  }
                }
              }
              
              // Auth Persistence 설정 (iOS 필수)
              if (auth && auth.setPersistence) {
                try {
                  await auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);
                  console.log('[Dashboard] phase2Firestore: Auth Persistence 설정 완료 (LOCAL) - iOS Bluefy 호환');
                } catch (persistErr) {
                  console.warn('[Dashboard] phase2Firestore: Auth Persistence 설정 실패:', persistErr);
                }
              } else if (auth) {
                console.warn('[Dashboard] phase2Firestore: auth.setPersistence 메서드 없음 (호환성 모드 가능)');
              }
            } catch (persistErr) {
              console.warn('[Dashboard] phase2Firestore: Auth Persistence 설정 중 오류:', persistErr);
            }
          }
          
          let firestore = window.firestore;
          if (window.parent && window.parent !== window) {
            try {
              firestore = window.parent.firestore || (window.parent.window && window.parent.window.firestore);
            } catch (e) {
              console.warn('[Dashboard] parent.firestore 접근 실패 (iOS 샌드박스 가능성):', e);
            }
          }
          
          // Standalone Fallback (iOS Bluefy 필수)
          if (!firestore && typeof window.initFirebaseStandalone === 'function') {
            try {
              var standalone = window.initFirebaseStandalone();
              if (standalone && standalone.firestore) {
                firestore = standalone.firestore;
                window.firestore = firestore;
                console.log('[Dashboard] phase2Firestore: Standalone Fallback 성공');
              }
            } catch (e) {
              console.warn('[Dashboard] phase2Firestore: Standalone Fallback 실패:', e);
            }
          }
          
          // Firebase SDK 직접 초기화 (최종 백업)
          if (!firestore && typeof firebase !== 'undefined' && firebase.apps && firebase.apps.length > 0) {
            try {
              firestore = firebase.firestore();
              window.firestore = firestore;
              console.log('[Dashboard] phase2Firestore: Firebase SDK 직접 초기화 성공');
            } catch (e) {
              console.warn('[Dashboard] phase2Firestore: Firebase SDK 직접 초기화 실패:', e);
            }
          }
          
          if (!firestore || !userId) {
            console.warn('[Dashboard] phase2Firestore: Firestore 또는 userId 없음', {
              hasFirestore: !!firestore,
              hasUserId: !!userId
            });
            return;
          }
          
          try {
            const userDoc = await firestore.collection('users').doc(userId).get();
            if (!userDoc.exists) return;
            const userData = userDoc.data();
            applyProfileFromUser({ id: userId, ...userData });
          } catch (e) {
            console.warn('[Dashboard] Firestore 프로필 보강 실패:', e);
          }
        }
        
        const uid = phase1Immediate();
        
        const onParentUser = function (e) {
          try {
            if (e.data && e.data.type === 'DASHBOARD_USER' && e.data.user) {
              if (window.parent && window.parent !== window) {
                var origin = e.origin || '';
                var parentOrigin = window.location.origin || '';
                if (origin === parentOrigin || origin === '*' || parentOrigin === '') {
                  applyProfileFromUser(e.data.user);
                }
              } else {
                applyProfileFromUser(e.data.user);
              }
            }
          } catch (err) {
            console.warn('[Dashboard] postMessage 처리 오류:', err);
          }
        };
        window.addEventListener('message', onParentUser);
        
        // iOS Bluefy: 즉시 Standalone Fallback 시도
        if (isMobile() && typeof window.initFirebaseStandalone === 'function') {
          try {
            var standalone = window.initFirebaseStandalone();
            if (standalone && standalone.firestore) {
              window.firestore = standalone.firestore;
              if (standalone.auth) {
                window.auth = standalone.auth;
                // Auth Persistence 설정
                if (standalone.auth.setPersistence) {
                  standalone.auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL)
                    .then(function() {
                      console.log('[Dashboard] 초기 진입: Auth Persistence 설정 완료 (LOCAL)');
                    })
                    .catch(function(e) {
                      console.warn('[Dashboard] 초기 진입: Auth Persistence 설정 실패:', e);
                    });
                }
              }
              console.log('[Dashboard] 초기 진입: Standalone Fallback 즉시 성공');
              if (uid) phase2Firestore(uid);
            }
          } catch (e) {
            console.warn('[Dashboard] 초기 진입: Standalone Fallback 실패, 일반 로직 진행:', e);
          }
        }
        
        let firestoreCheck = setInterval(function () {
          var fs = window.firestore;
          if (window.parent && window.parent !== window) {
            try {
              fs = window.parent.firestore || (window.parent.window && window.parent.window.firestore) || fs;
            } catch (e) {
              // iOS 샌드박스로 인한 접근 실패는 무시
            }
          }
          
          // Standalone Fallback 시도
          if (!fs && typeof window.initFirebaseStandalone === 'function') {
            try {
              var standalone = window.initFirebaseStandalone();
              if (standalone && standalone.firestore) {
                fs = standalone.firestore;
                window.firestore = fs;
                if (standalone.auth) {
                  window.auth = standalone.auth;
                }
              }
            } catch (e) {
              console.warn('[Dashboard] firestoreCheck: Standalone Fallback 실패:', e);
            }
          }
          
          // Firebase SDK 직접 초기화
          if (!fs && typeof firebase !== 'undefined' && firebase.apps && firebase.apps.length > 0) {
            try {
              fs = firebase.firestore();
              window.firestore = fs;
            } catch (e) {
              console.warn('[Dashboard] firestoreCheck: Firebase SDK 직접 초기화 실패:', e);
            }
          }
          
          if (fs && uid) {
            clearInterval(firestoreCheck);
            phase2Firestore(uid);
          }
        }, isMobile() ? 300 : 200);
        const t = setTimeout(function () {
          clearInterval(firestoreCheck);
          // 최종 시도: Standalone Fallback 강제 실행
          if (!window.firestore && typeof window.initFirebaseStandalone === 'function') {
            try {
              var standalone = window.initFirebaseStandalone();
              if (standalone && standalone.firestore) {
                window.firestore = standalone.firestore;
                if (standalone.auth) {
                  window.auth = standalone.auth;
                }
                console.log('[Dashboard] firestoreCheck 타임아웃: 최종 Standalone Fallback 성공');
              }
            } catch (e) {
              console.error('[Dashboard] firestoreCheck 타임아웃: 최종 Standalone Fallback 실패:', e);
            }
          }
          if (uid) phase2Firestore(uid);
        }, isMobile() ? 20000 : 8000);
        return function () {
          window.removeEventListener('message', onParentUser);
          clearInterval(firestoreCheck);
          clearTimeout(t);
        };
      }, []);
      
      // 재시도 버튼용 ref (외부에서 호출 가능하도록)
      const retryLogsRef = useRef(null);
      
      // 최근 훈련 로그 로드 (주간 목표·훈련 트렌드용) — 휴대폰 iframe에서 Firestore 지연 대기 + 재시도
      useEffect(() => {
        var retryCount = 0;
        var maxRetries = isMobile() ? 5 : 3; // 휴대폰은 더 많은 재시도
        var retryDelay = isMobile() ? 3000 : 2000; // 휴대폰은 더 긴 대기 시간
        var isMounted = true;
        
        async function loadRecentLogs(currentRetry) {
          currentRetry = currentRetry || 0;
          if (!userProfile || !userProfile.id) return;
          
          // 로그 로딩 시작
          if (isMounted && currentRetry === 0) {
            setLogsLoading(true);
            setLogsLoadError(null);
          }
          
          function getFirestore() {
            // 1순위: window.firestore (현재 창)
            var fs = window.firestore;
            
            // 2순위: window.parent.firestore (부모 창, iframe 환경) - iOS Bluefy에서는 차단될 수 있음
            if (!fs && window.parent && window.parent !== window) {
              try {
                fs = window.parent.firestore || (window.parent.window && window.parent.window.firestore) || fs;
              } catch (e) {
                console.warn('[Dashboard] parent.firestore 접근 실패 (iOS 샌드박스 가능성):', e);
              }
            }
            
            // 3순위: Firebase SDK를 사용하여 직접 초기화 (백업 로직)
            if (!fs && typeof firebase !== 'undefined' && firebase.apps && firebase.apps.length > 0) {
              try {
                fs = firebase.firestore();
                window.firestore = fs; // 전역에 저장하여 다음 호출 시 재사용
                console.log('[Dashboard] Firestore 직접 초기화 성공 (백업 로직)');
              } catch (e) {
                console.warn('[Dashboard] Firestore 직접 초기화 실패:', e);
              }
            }
            
            // 4순위: Standalone Fallback (강제 독립 초기화) - iOS Bluefy 필수
            if (!fs && typeof window.initFirebaseStandalone === 'function') {
              try {
                var standalone = window.initFirebaseStandalone();
                if (standalone && standalone.firestore) {
                  fs = standalone.firestore;
                  window.firestore = fs;
                  console.log('[Dashboard] Firebase Standalone Fallback 성공 (iOS Bluefy 호환)');
                }
              } catch (e) {
                console.warn('[Dashboard] Standalone Fallback 실패:', e);
              }
            }
            
            // 5순위: firebaseConfig.js가 아직 로드되지 않았다면 대기
            if (!fs && typeof firebase === 'undefined') {
              console.warn('[Dashboard] Firebase SDK가 아직 로드되지 않음');
            }
            
            console.log('[Dashboard] Firestore 확인:', {
              hasWindowFirestore: !!window.firestore,
              hasParentFirestore: !!(window.parent && window.parent !== window && window.parent.firestore),
              hasFirebaseSDK: typeof firebase !== 'undefined',
              firebaseAppsLength: (typeof firebase !== 'undefined' && firebase.apps) ? firebase.apps.length : 0,
              hasStandaloneInit: typeof window.initFirebaseStandalone === 'function',
              result: !!fs,
              device: isMobile() ? 'mobile' : 'desktop',
              isBluefy: /Bluefy/i.test(navigator.userAgent || '')
            });
            return fs;
          }
          
          var firestore = getFirestore();
          if (!firestore) {
            var deadline = Date.now() + (isMobile() ? 20000 : 10000); // 휴대폰은 더 긴 대기
            while (!firestore && Date.now() < deadline) {
              await new Promise(function(r) { setTimeout(r, isMobile() ? 300 : 200); });
              firestore = getFirestore();
            }
          }
          if (!firestore) {
            if (currentRetry < maxRetries) {
              console.warn('[Dashboard] 훈련 로그: Firestore 미준비, 재시도 ' + (currentRetry + 1) + '/' + maxRetries);
              setTimeout(function() {
                if (isMounted) loadRecentLogs(currentRetry + 1);
              }, retryDelay);
              return;
            }
            console.warn('[Dashboard] 훈련 로그: Firestore 미준비(최종 타임아웃). 주간 목표/트렌드 미표시.');
            if (isMounted) {
              setLogsLoaded(true);
              setRecentLogs([]);
            }
            return;
          }
          
          try {
            // AI 분석용 훈련 로그 수집
            // 출처: Firestore users/{userId}/logs 서브컬렉션
            // 기간: 최근 30일 (오늘 기준)
            // 필터: source='strava' 또는 source 없음 (Stelvio 직접 입력 제외)
            // 최대: 30개 (날짜 내림차순)
            var thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            var dateStr = thirtyDaysAgo.toISOString().split('T')[0];
            var logs = [];
            
            try {
              var userLogsRef = firestore.collection('users').doc(userProfile.id).collection('logs');
              console.log('[Dashboard] Firestore 쿼리 시작:', {
                userId: userProfile.id,
                dateStr: dateStr,
                device: isMobile() ? 'mobile' : 'desktop'
              });
              
              var logsSnapshot;
              try {
                logsSnapshot = await userLogsRef.orderBy('date', 'desc').limit(50).get();
                console.log('[Dashboard] orderBy 쿼리 성공:', logsSnapshot.docs.length + '개 문서');
              } catch (indexErr) {
                console.warn('[Dashboard] orderBy 실패, limit만 사용:', indexErr);
                logsSnapshot = await userLogsRef.limit(100).get();
                console.log('[Dashboard] limit 쿼리 성공:', logsSnapshot.docs.length + '개 문서');
              }
              
              var raw = [];
              logsSnapshot.docs.forEach(function(doc) {
                var d = doc.data();
                // Strava 활동만 포함 (source='strava' 또는 source 없음)
                if ((d.source === 'strava' || !d.source) && d.date && d.date >= dateStr) {
                  // 로그 필드: { id, activity_id, date, title, distance_km, time, duration_sec, tss, user_id, source, ... }
                  raw.push({ id: doc.id, ...d });
                }
              });
              raw.sort(function(a, b) { return (b.date || '').localeCompare(a.date || ''); });
              logs = raw.slice(0, 30);
              
              console.log('[Dashboard] 로그 필터링 결과:', {
                totalDocs: logsSnapshot.docs.length,
                afterFilter: raw.length,
                finalLogs: logs.length,
                dateRange: logs.length > 0 ? (logs[logs.length - 1].date + ' ~ ' + logs[0].date) : '없음'
              });
              
              // 휴대폰에서 로그가 비어있고 재시도 가능하면 재시도
              if (logs.length === 0 && currentRetry < maxRetries && isMobile()) {
                console.warn('[Dashboard] 휴대폰: 로그가 비어있음, 재시도 ' + (currentRetry + 1) + '/' + maxRetries, {
                  totalDocs: logsSnapshot.docs.length,
                  afterFilter: raw.length,
                  dateStr: dateStr
                });
                setTimeout(function() {
                  if (isMounted) loadRecentLogs(currentRetry + 1);
                }, retryDelay);
                return;
              }
              
              if (isMounted) {
                setRecentLogs(logs);
                setLogsLoaded(true);
                setLogsLoading(false);
                setLogsLoadError(null);
                console.log('[Dashboard] 훈련 로그 로드 성공:', logs.length + '개 (AI 분석용)', {
                  device: isMobile() ? 'mobile' : 'desktop',
                  retryCount: currentRetry,
                  totalDocs: logsSnapshot.docs.length,
                  afterFilter: raw.length,
                  dateRange: logs.length > 0 ? (logs[logs.length - 1].date + ' ~ ' + logs[0].date) : '없음',
                  weeklyTss: logs.length > 0 ? (function() {
                    var today = new Date();
                    var dayOfWeek = today.getDay();
                    var mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                    var monday = new Date(today);
                    monday.setDate(today.getDate() + mondayOffset);
                    monday.setHours(0, 0, 0, 0);
                    var mondayStr = monday.toISOString().split('T')[0];
                    var weeklyTss = 0;
                    logs.forEach(function(log) {
                      if (log.date && log.date >= mondayStr) {
                        weeklyTss += (Number(log.tss) || 0);
                      }
                    });
                    return Math.round(weeklyTss);
                  })() : 0
                });
              }
            } catch (queryErr) {
              console.warn('[Dashboard] 훈련 로그 조회 실패:', queryErr);
              if (currentRetry < maxRetries && isMounted) {
                console.warn('[Dashboard] 훈련 로그 재시도 ' + (currentRetry + 1) + '/' + maxRetries);
                setTimeout(function() {
                  if (isMounted) loadRecentLogs(currentRetry + 1);
                }, retryDelay);
                return;
              }
              // 최종 실패 시에도 빈 배열로 설정하되, 명확히 로그
              if (isMounted) {
                console.error('[Dashboard] 훈련 로그 로드 최종 실패 (재시도 ' + maxRetries + '회 후):', queryErr);
                var errMsg = queryErr && queryErr.message ? queryErr.message : String(queryErr);
                setRecentLogs([]);
                setLogsLoaded(true);
                setLogsLoading(false);
                setLogsLoadError('훈련 로그 조회 실패: ' + errMsg.substring(0, 100));
                // 주간 목표는 0으로 설정
                setStats(function(prev) {
                  var challenge = userProfile.challenge || 'Fitness';
                  var weeklyTarget = 100;
                  if (typeof window.getWeeklyTargetTSS === 'function') {
                    var targetInfo = window.getWeeklyTargetTSS(challenge);
                    weeklyTarget = targetInfo.target;
                  }
                  return { ...prev, weeklyGoal: weeklyTarget, weeklyProgress: 0 };
                });
              }
            }
            
            // 이번 주(월요일~일요일)의 TSS 계산
            var today = new Date();
            var dayOfWeek = today.getDay(); // 0=일요일, 1=월요일, ..., 6=토요일
            var mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // 월요일까지의 일수
            var monday = new Date(today);
            monday.setDate(today.getDate() + mondayOffset);
            monday.setHours(0, 0, 0, 0);
            var mondayStr = monday.toISOString().split('T')[0];
            
            var weeklyTss = 0;
            logs.forEach(function(log) {
              if (log.date && log.date >= mondayStr) {
                weeklyTss += (Number(log.tss) || 0);
              }
            });
            var weeklyTssRounded = Math.round(weeklyTss);
            
            var challenge = userProfile.challenge || 'Fitness';
            var weeklyTarget = 100;
            if (typeof window.getWeeklyTargetTSS === 'function') {
              var targetInfo = window.getWeeklyTargetTSS(challenge);
              weeklyTarget = targetInfo.target;
            }
            if (isMounted) {
              setStats(function(prev) {
                return { ...prev, weeklyGoal: weeklyTarget, weeklyProgress: Math.min(weeklyTssRounded, 9999) };
              });
              console.log('[Dashboard] 주간 목표 계산:', {
                weeklyTss: weeklyTssRounded,
                weeklyTarget: weeklyTarget,
                monday: mondayStr,
                logsCount: logs.length
              });
              
              var last7 = logs.slice(0, 7).reverse();
              var chartData = last7.map(function(log) {
                return {
                  date: new Date(log.date).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' }),
                  fitness: Number(log.tss) || 0,
                  fatigue: (Number(log.tss) || 0) * 0.7
                };
              });
              setFitnessData(chartData);
            }
          } catch (e) {
            console.error('[Dashboard] 훈련 로그 로드 오류:', e);
            if (currentRetry < maxRetries && isMounted) {
              console.warn('[Dashboard] 훈련 로그 오류 재시도 ' + (currentRetry + 1) + '/' + maxRetries);
              setTimeout(function() {
                if (isMounted) loadRecentLogs(currentRetry + 1);
              }, retryDelay);
            } else if (isMounted) {
              // 최종 실패 시에도 상태 설정
              console.error('[Dashboard] 훈련 로그 로드 최종 실패:', e);
              var errMsg = e && e.message ? e.message : String(e);
              setRecentLogs([]);
              setLogsLoaded(true);
              setLogsLoading(false);
              setLogsLoadError('훈련 로그 로드 오류: ' + errMsg.substring(0, 100));
              setStats(function(prev) {
                var challenge = userProfile.challenge || 'Fitness';
                var weeklyTarget = 100;
                if (typeof window.getWeeklyTargetTSS === 'function') {
                  var targetInfo = window.getWeeklyTargetTSS(challenge);
                  weeklyTarget = targetInfo.target;
                }
                return { ...prev, weeklyGoal: weeklyTarget, weeklyProgress: 0 };
              });
            }
          }
        }
        
        if (userProfile && userProfile.id) {
          // 로그 로딩 시작
          setLogsLoading(true);
          setLogsLoadError(null);
          loadRecentLogs(0);
        } else {
          // userProfile이 없으면 로딩 상태 해제
          setLogsLoading(false);
        }
        
        // 외부에서 재시도할 수 있도록 ref에 함수 저장
        retryLogsRef.current = function() {
          if (userProfile && userProfile.id && isMounted) {
            setLogsLoading(true);
            setLogsLoadError(null);
            setLogsLoaded(false);
            loadRecentLogs(0);
          }
        };
        
        return function() {
          isMounted = false;
          retryLogsRef.current = null;
        };
      }, [userProfile]);
      
      // Gemini AI 코치 분석 호출 (로그 로드 완료 후 자동 재호출)
      useEffect(() => {
        async function fetchCoachAnalysis() {
          if (!userProfile) {
            setLoading(false);
            return;
          }
          
          // logsLoaded가 false이거나 logsLoading이 true이면 로그 로딩이 완료되지 않았으므로 대기
          if (!logsLoaded || logsLoading) {
            console.log('[Dashboard] AI 분석 대기: 로그 로딩 중...', { logsLoaded: logsLoaded, logsLoading: logsLoading });
            return;
          }
          
          // 로그 로딩이 실패했으면 AI 분석 실행하지 않음
          if (logsLoadError) {
            console.warn('[Dashboard] AI 분석 건너뜀: 로그 로딩 실패', logsLoadError);
            setCoachData({
              condition_score: 50,
              training_status: 'Building Base',
              vo2max_estimate: 40,
              coach_comment: (userProfile && userProfile.name || '사용자') + '님, 훈련 데이터를 불러오지 못했습니다. 잠시 후 다시 시도해주세요.',
              recommended_workout: 'Active Recovery (Z1)',
              error_reason: logsLoadError
            });
            setAiPairingStatus(false);
            setLoading(false);
            return;
          }
          
          var logs = Array.isArray(recentLogs) ? recentLogs : [];
          
          // 휴대폰에서 로그가 비어있으면 추가 대기 후 재확인 (Firestore 지연 가능성)
          if (logs.length === 0 && isMobile()) {
            console.warn('[Dashboard] 휴대폰: 로그가 비어있음, 재확인 시작...');
            
            // 여러 번 재확인 (최대 3회, 각 3초 간격)
            var checkAttempt = 0;
            var maxCheckAttempts = 3;
            var checkInterval = 3000;
            
            var checkLogs = function() {
              if (checkAttempt >= maxCheckAttempts) {
                console.warn('[Dashboard] 휴대폰: 재확인 최종 실패, 빈 로그로 진행');
                // 최종 실패 시에도 fallback 메시지 표시
                setCoachData({
                  condition_score: 50,
                  training_status: 'Building Base',
                  vo2max_estimate: 40,
                  coach_comment: (userProfile && userProfile.name || '사용자') + '님, 훈련 데이터를 불러오는 중입니다. 잠시 후 다시 확인해주세요.',
                  recommended_workout: 'Active Recovery (Z1)',
                  error_reason: '휴대폰에서 훈련 로그를 불러오지 못했습니다. 네트워크 연결을 확인하거나 잠시 후 다시 시도해주세요.'
                });
                setAiPairingStatus(false);
                setLoading(false);
                return;
              }
              
              checkAttempt++;
              console.log('[Dashboard] 휴대폰: 재확인 시도 ' + checkAttempt + '/' + maxCheckAttempts);
              
              if (userProfile) {
                var firestore = window.firestore;
                if (window.parent && window.parent !== window) {
                  try {
                    firestore = window.parent.firestore || (window.parent.window && window.parent.window.firestore) || firestore;
                  } catch (e) {
                    console.warn('[Dashboard] parent.firestore 접근 실패:', e);
                  }
                }
                
                if (firestore) {
                  var thirtyDaysAgo = new Date();
                  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                  var dateStr = thirtyDaysAgo.toISOString().split('T')[0];
                  
                  firestore.collection('users').doc(userProfile.id).collection('logs')
                    .limit(100).get()
                    .then(function(snapshot) {
                      var newLogs = [];
                      snapshot.docs.forEach(function(doc) {
                        var d = doc.data();
                        if ((d.source === 'strava' || !d.source) && d.date && d.date >= dateStr) {
                          newLogs.push({ id: doc.id, ...d });
                        }
                      });
                      newLogs.sort(function(a, b) { return (b.date || '').localeCompare(a.date || ''); });
                      newLogs = newLogs.slice(0, 30);
                      
                      if (newLogs.length > 0) {
                        console.log('[Dashboard] 휴대폰: 재확인 후 로그 발견:', newLogs.length + '개');
                        setRecentLogs(newLogs);
                        
                        // 주간 목표 재계산
                        var today = new Date();
                        var dayOfWeek = today.getDay();
                        var mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
                        var monday = new Date(today);
                        monday.setDate(today.getDate() + mondayOffset);
                        monday.setHours(0, 0, 0, 0);
                        var mondayStr = monday.toISOString().split('T')[0];
                        
                        var weeklyTss = 0;
                        newLogs.forEach(function(log) {
                          if (log.date && log.date >= mondayStr) {
                            weeklyTss += (Number(log.tss) || 0);
                          }
                        });
                        var weeklyTssRounded = Math.round(weeklyTss);
                        
                        var challenge = userProfile.challenge || 'Fitness';
                        var weeklyTarget = 100;
                        if (typeof window.getWeeklyTargetTSS === 'function') {
                          var targetInfo = window.getWeeklyTargetTSS(challenge);
                          weeklyTarget = targetInfo.target;
                        }
                        setStats(function(prev) {
                          return { ...prev, weeklyGoal: weeklyTarget, weeklyProgress: Math.min(weeklyTssRounded, 9999) };
                        });
                        
                        // 훈련 트렌드 데이터 업데이트
                        var last7 = newLogs.slice(0, 7).reverse();
                        var chartData = last7.map(function(log) {
                          return {
                            date: new Date(log.date).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' }),
                            fitness: Number(log.tss) || 0,
                            fatigue: (Number(log.tss) || 0) * 0.7
                          };
                        });
                        setFitnessData(chartData);
                        
                        // AI 분석은 useEffect가 자동으로 재실행됨 (recentLogs 변경 감지)
                      } else if (checkAttempt < maxCheckAttempts) {
                        // 아직 로그가 없으면 다음 시도
                        setTimeout(checkLogs, checkInterval);
                      }
                    })
                    .catch(function(err) {
                      console.warn('[Dashboard] 휴대폰: 재확인 실패:', err);
                      if (checkAttempt < maxCheckAttempts) {
                        setTimeout(checkLogs, checkInterval);
                      }
                    });
                } else if (checkAttempt < maxCheckAttempts) {
                  console.warn('[Dashboard] 휴대폰: Firestore 없음, 재시도...');
                  setTimeout(checkLogs, checkInterval);
                }
              }
            };
            
            // 첫 재확인 시작
            setTimeout(checkLogs, checkInterval);
            
            // 빈 로그로 AI 분석 실행하지 않음
            return;
          }
          
          // logsHash에 TSS 합계도 포함하여 더 정확한 캐시 키 생성
          var logsTssSum = logs.reduce(function(s, log) { return s + (Number(log.tss) || 0); }, 0);
          var logsHash = logs.length > 0 
            ? logs.length + '_' + (logs[0] && logs[0].date || '') + '_' + (logs[logs.length - 1] && logs[logs.length - 1].date || '') + '_' + Math.round(logsTssSum)
            : 'empty';
          var cacheKey = 'coach_analysis_' + userProfile.id + '_' + logsHash;
          console.log('[Dashboard] AI 분석 시작:', {
            logsCount: logs.length,
            logsHash: logsHash,
            cacheKey: cacheKey.substring(0, 50) + '...',
            device: isMobile() ? 'mobile' : 'desktop'
          });
          
          try {
            var useCache = false;
            var skipCache = retryCoach > 0;
            if (!skipCache) {
              try {
                var cached = localStorage.getItem(cacheKey);
                if (cached) {
                  var parsed = JSON.parse(cached);
                  var oneHour = 60 * 60 * 1000;
                  if (parsed.data && parsed.timestamp && (Date.now() - parsed.timestamp < oneHour) && !(parsed.data && parsed.data.error_reason)) {
                    setCoachData(parsed.data);
                    useCache = true;
                  }
                }
              } catch (e) {
                useCache = false;
              }
            }
            if (useCache) {
              setAiPairingStatus(true);
              setLoading(false);
              return;
            }
            if (skipCache) setLoading(true);
            
            if (typeof window.callGeminiCoach === 'function') {
              // AI 분석에 전달되는 데이터:
              // - userProfile: { id, name, ftp, weight, grade, challenge, acc_points, rem_points, ... }
              // - logs: 최근 30일간 훈련 로그 배열 (Firestore users/{userId}/logs, source='strava' 또는 없음)
              //   각 로그: { id, activity_id, date, title, distance_km, time, duration_sec, tss, user_id, source, ... }
              var analysis = await window.callGeminiCoach(userProfile, logs);
              var isFallback = !analysis || (analysis.coach_comment && analysis.coach_comment.indexOf('일시적인 오류') !== -1) || !!(analysis && analysis.error_reason);
              setCoachData(analysis);
              setAiPairingStatus(!isFallback);
              if (!isFallback && analysis && !analysis.error_reason) {
                try {
                  localStorage.setItem(cacheKey, JSON.stringify({ data: analysis, timestamp: Date.now() }));
                } catch (e) {}
              }
            }
          } catch (error) {
            var errMsg = (error && error.message) ? error.message : '알 수 없는 오류';
            console.error('AI 코치 분석 오류:', error);
            setAiPairingStatus(false);
            setCoachData({
              condition_score: 50,
              training_status: 'Building Base',
              vo2max_estimate: 40,
              coach_comment: (userProfile && userProfile.name || '사용자') + '님, 데이터 분석 중 일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.',
              recommended_workout: 'Active Recovery (Z1)',
              error_reason: errMsg
            });
          } finally {
            setLoading(false);
          }
        }
        
        if (userProfile) {
          fetchCoachAnalysis();
        } else {
          setLoading(false);
        }
      }, [userProfile, recentLogs, retryCoach, logsLoaded, logsLoading, logsLoadError]);
      
      // 등급 뱃지 텍스트
      const getGradeBadge = (grade) => {
        const badges = {
          '1': '💎 Diamond',
          '2': '⭐ Member',
          '3': '👑 Admin'
        };
        return badges[grade] || '⭐ Member';
      };
      
      if (loading) {
        return (
          <div className="max-w-[480px] mx-auto min-h-screen bg-gray-50 flex items-center justify-center">
            <div className="text-center">
              <div className="skeleton w-32 h-32 rounded-full mx-auto mb-4"></div>
              <div className="skeleton w-48 h-6 mx-auto mb-2"></div>
              <div className="skeleton w-64 h-4 mx-auto"></div>
            </div>
          </div>
        );
      }
      
      return (
        <div className="max-w-[480px] mx-auto min-h-screen bg-gray-50 scrollbar-hide">
          {/* Header */}
          <header className="sticky top-0 z-10 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white font-bold">
                  {userProfile?.name?.charAt(0) || 'U'}
                </div>
                <div>
                  <div className="font-semibold text-gray-900">{userProfile?.name || '사용자'}</div>
                  <div className="text-xs text-gray-500">{getGradeBadge(userProfile?.grade)}</div>
                </div>
              </div>
              <button
                className="p-2 rounded-lg hover:bg-gray-100 active:opacity-80 transition-all"
                onClick={() => {
                  // 프로필 편집 모달 열기 (추후 구현)
                  alert('프로필 편집 기능은 추후 구현 예정입니다.');
                }}
              >
                <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
              </button>
            </div>
          </header>
          
          <div className="px-4 py-6 space-y-6 pb-24">
            {/* Status Control Center */}
            <div className="flex gap-3 overflow-x-auto scrollbar-hide pb-2">
              <DashboardCard className="min-w-[140px]">
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${aiPairingStatus ? 'bg-green-500' : 'bg-gray-300'}`}></div>
                  <span className="text-sm text-gray-700">AI 페어링</span>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {aiPairingStatus ? '연결됨' : '연결 대기'}
                </div>
              </DashboardCard>
              
              <DashboardCard className="min-w-[140px]">
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${stravaStatus.connected ? 'bg-green-500' : 'bg-gray-300'}`}></div>
                  <span className="text-sm text-gray-700">Strava</span>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {stravaStatus.connected 
                    ? stravaStatus.lastSync 
                      ? `동기화: ${new Date(stravaStatus.lastSync).toLocaleDateString('ko-KR')}`
                      : '연결됨'
                    : '연결 대기'}
                </div>
              </DashboardCard>
            </div>
            
            {/* Gemini Coach Insight */}
            <DashboardCard className="bg-gradient-to-br from-blue-50 to-purple-50 border-2 border-blue-200">
              {coachData ? (
                <>
                  <div className="flex items-center justify-center mb-4">
                    <CircularProgress value={coachData.condition_score} />
                  </div>
                  <div className="text-center mb-3">
                    <div className="text-lg font-bold text-gray-900 mb-1">
                      {coachData.training_status}
                    </div>
                    <div className="text-sm text-gray-600">
                      VO₂max 추정: {coachData.vo2max_estimate} ml/kg/min
                    </div>
                  </div>
                  <div className="bg-white/80 rounded-xl p-4 mb-3">
                    <p className="text-sm text-gray-800 leading-relaxed">
                      {coachData.coach_comment}
                    </p>
                    {coachData.error_reason && (
                      <div className="mt-3 pt-3 border-t border-amber-200 space-y-1">
                        <p className="text-xs text-amber-700">원인: {coachData.error_reason}</p>
                        {(coachData.error_reason.indexOf('API 키') !== -1 || coachData.error_reason.indexOf('geminiApiKey') !== -1) && (
                          <p className="text-xs text-gray-600">환경 설정에서 Gemini API 키를 입력한 뒤 &quot;다시 분석&quot;을 눌러 주세요.</p>
                        )}
                        {(coachData.error_reason.indexOf('네트워크 오류') !== -1 || coachData.error_reason.indexOf('Failed to fetch') !== -1) && (
                          <p className="text-xs text-gray-600">인터넷 연결을 확인하거나, 방화벽/보안 소프트웨어가 API 요청을 차단하지 않는지 확인해 주세요.</p>
                        )}
                      </div>
                    )}
                  </div>
                  <div className="text-center flex flex-wrap items-center justify-center gap-2">
                    <span className="inline-block bg-blue-100 text-blue-800 text-xs font-semibold px-3 py-1 rounded-full">
                      추천: {coachData.recommended_workout}
                    </span>
                    {coachData.error_reason && (
                      <button
                        type="button"
                        onClick={() => {
                          try {
                            localStorage.removeItem('coach_analysis_' + (userProfile && userProfile.id));
                          } catch (e) {}
                          setRetryCoach(function(c) { return c + 1; });
                        }}
                        className="inline-block bg-amber-100 text-amber-800 text-xs font-semibold px-3 py-1.5 rounded-full hover:bg-amber-200 active:opacity-80 min-h-[44px]"
                      >
                        다시 분석
                      </button>
                    )}
                  </div>
                </>
              ) : (
                <div className="text-center py-8">
                  <div className="skeleton w-24 h-24 rounded-full mx-auto mb-4"></div>
                  <div className="skeleton w-32 h-4 mx-auto mb-2"></div>
                  <div className="skeleton w-48 h-3 mx-auto"></div>
                </div>
              )}
            </DashboardCard>
            
            {/* Stats Grid (2x2) */}
            <div className="grid grid-cols-2 gap-3">
              {/* Power Card */}
              <DashboardCard title="파워">
                <div className="text-2xl font-bold text-gray-900 mb-1">{stats.ftp}W</div>
                <div className="text-sm text-gray-600">{stats.wkg} W/kg</div>
              </DashboardCard>
              
              {/* Rewards/Points Card */}
              <DashboardCard title="포인트">
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-2xl">💰</span>
                  <div>
                    <div className="text-lg font-bold text-gray-900">{formatPoints(stats.currentPoints)}</div>
                    <div className="text-xs text-gray-500">보유</div>
                  </div>
                </div>
                <div className="text-xs text-gray-600 border-t border-gray-100 pt-2 mt-2">
                  누적: {formatPoints(stats.totalPoints)}pt
                </div>
              </DashboardCard>
              
              {/* Physique Card */}
              <DashboardCard title="체형">
                <div className="text-2xl font-bold text-gray-900 mb-1">{stats.weight}kg</div>
                <div className="text-sm text-gray-600">체중</div>
              </DashboardCard>
              
              {/* Progress Card */}
              <DashboardCard title="주간 목표">
                {logsLoading ? (
                  <div className="flex flex-col items-center justify-center py-4">
                    <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-2"></div>
                    <div className="text-xs text-gray-500">데이터 로딩 중...</div>
                  </div>
                ) : logsLoadError ? (
                  <div className="flex flex-col items-center justify-center py-4 space-y-2">
                    <div className="text-xs text-red-600 text-center mb-2">{logsLoadError}</div>
                    <button
                      type="button"
                      onClick={function() {
                        if (retryLogsRef.current) {
                          retryLogsRef.current();
                        }
                      }}
                      className="px-3 py-1.5 bg-blue-500 text-white text-xs font-semibold rounded-lg hover:bg-blue-600 active:scale-95 transition-all min-h-[44px]"
                    >
                      다시 시도
                    </button>
                  </div>
                ) : (
                  <>
                    <div className="relative w-16 h-16 mx-auto mb-2">
                      <svg className="w-16 h-16 transform -rotate-90">
                        <circle
                          cx="32"
                          cy="32"
                          r="28"
                          stroke="#e5e7eb"
                          strokeWidth="6"
                          fill="none"
                        />
                        <circle
                          cx="32"
                          cy="32"
                          r="28"
                          stroke="#3b82f6"
                          strokeWidth="6"
                          fill="none"
                          strokeDasharray={`${2 * Math.PI * 28}`}
                          strokeDashoffset={`${2 * Math.PI * 28 * (1 - Math.min(stats.weeklyProgress / (stats.weeklyGoal || 100), 1))}`}
                          strokeLinecap="round"
                        />
                      </svg>
                      <div className="absolute inset-0 flex items-center justify-center">
                        <span className="text-sm font-bold text-gray-900">
                          {Math.min(Math.round((stats.weeklyProgress / (stats.weeklyGoal || 100)) * 100), 100)}%
                        </span>
                      </div>
                    </div>
                    <div className="text-xs text-gray-600 text-center">
                      {stats.weeklyProgress}/{stats.weeklyGoal || 100} TSS
                    </div>
                  </>
                )}
              </DashboardCard>
            </div>
            
            {/* Training Trend Chart */}
            {logsLoading ? (
              <DashboardCard title="훈련 트렌드 (최근 7일)">
                <div className="h-[200px] flex items-center justify-center">
                  <div className="text-center">
                    <div className="w-8 h-8 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-2"></div>
                    <div className="text-sm text-gray-500">데이터 로딩 중...</div>
                  </div>
                </div>
              </DashboardCard>
            ) : logsLoadError ? (
              <DashboardCard title="훈련 트렌드 (최근 7일)">
                <div className="h-[200px] flex items-center justify-center">
                  <div className="text-center">
                    <div className="text-sm text-red-600 mb-2">{logsLoadError}</div>
                    <button
                      type="button"
                      onClick={function() {
                        if (retryLogsRef.current) {
                          retryLogsRef.current();
                        }
                      }}
                      className="px-3 py-1.5 bg-blue-500 text-white text-xs font-semibold rounded-lg hover:bg-blue-600 active:scale-95 transition-all min-h-[44px]"
                    >
                      다시 시도
                    </button>
                  </div>
                </div>
              </DashboardCard>
            ) : (
              <TrainingTrendChart data={fitnessData} />
            )}
          </div>
        </div>
      );
    }
    
    // React 앱 렌더링 (React 18 호환)
    const rootElement = document.getElementById('dashboard-root');
    if (ReactDOM.createRoot) {
      // React 18+
      const root = ReactDOM.createRoot(rootElement);
      root.render(<PerformanceDashboard />);
    } else {
      // React 17 이하
      ReactDOM.render(<PerformanceDashboard />, rootElement);
    }
  </script>
</body>
</html>
