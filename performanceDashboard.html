<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="STELVIO AI - Performance Dashboard">
  <title>STELVIO AI - Performance Dashboard</title>
  
  <!-- Tailwind / Babel CDN ê²½ê³  í•„í„° (ë°˜ë“œì‹œ ìµœìƒë‹¨, CDN ë¡œë“œ ì „) -->
  <script>
    (function() {
      if (typeof console === 'undefined' || !console.warn) return;
      var orig = console.warn;
      console.warn = function() {
        var msg = (arguments[0] && String(arguments[0])) || '';
        if (msg.indexOf('cdn.tailwindcss.com') !== -1 || msg.indexOf('Tailwind CSS') !== -1 && msg.indexOf('production') !== -1 ||
            msg.indexOf('in-browser Babel') !== -1 || msg.indexOf('precompile your scripts') !== -1 || (msg.indexOf('Babel') !== -1 && msg.indexOf('production') !== -1)) {
          return;
        }
        return orig.apply(console, arguments);
      };
    })();
  </script>
  
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React & ReactDOM CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone (JSX ë³€í™˜ìš©) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Chart.js (ì°¨íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
  <script src="assets/js/firebaseConfig.js"></script>
  
  <!-- í”„ë¡œì íŠ¸ ìŠ¤í¬ë¦½íŠ¸ (assets/js/) -->
  <script src="assets/js/trainingManager.js"></script>
  <script src="assets/js/stravaManager.js"></script>
  <script src="assets/js/userManager.js"></script>
  
  <!-- Dashboard ì „ìš©: Gemini ì½”ì¹˜ í”„ë¡¬í”„íŠ¸ ë° API (ì¸ë¼ì¸, 404 ë°©ì§€) -->
  <script>
    window.GEMINI_COACH_SYSTEM_PROMPT = `Role: ë‹¹ì‹ ì€ 'Stelvio AI'ì˜ ìˆ˜ì„ ì‚¬ì´í´ë§ ì½”ì¹˜ì´ì ë°ì´í„° ë¶„ì„ê°€ì…ë‹ˆë‹¤.
Context: ì‚¬ìš©ìì˜ í”„ë¡œí•„({{userProfile}})ê³¼ ìµœê·¼ 30ì¼ê°„ì˜ í›ˆë ¨ ë¡œê·¸({{recentLogs}})ë¥¼ ë¶„ì„í•˜ì—¬ JSON í˜•ì‹ìœ¼ë¡œ ì¸ì‚¬ì´íŠ¸ë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.
Task Requirements:
1. **Condition Score (0~100):** TSB(Training Stress Balance)ì™€ ìµœê·¼ ìš´ë™ ê°•ë„ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì»¨ë””ì…˜ ì ìˆ˜ë¥¼ ì‚°ì¶œí•˜ì„¸ìš”.
2. **Training Status:** í˜„ì¬ ìƒíƒœë¥¼ í•œ ë‹¨ì–´ë¡œ ì •ì˜í•˜ì„¸ìš” (ì˜ˆ: "Ready to Race", "Recovery Needed", "Building Base", "Peaking").
3. **Coach Comment:** ì‚¬ìš©ìì˜ ì´ë¦„({{userName}})ì„ ë¶€ë¥´ë©°, ìµœê·¼ í›ˆë ¨ ì„±ê³¼(FTP ë³€í™”, TSS ëˆ„ì  ë“±)ë¥¼ ì–¸ê¸‰í•˜ê³  ë™ê¸°ë¥¼ ë¶€ì—¬í•˜ëŠ” ë”°ëœ»í•œ ì¡°ì–¸ì„ í•œêµ­ì–´(ê²½ì–´ì²´)ë¡œ í•œ ë¬¸ì¥ ì‘ì„±í•˜ì„¸ìš”.
4. **VO2max Estimate:** íŒŒì›Œ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì¶”ì •ëœ VO2max ê°’ì„ ì •ìˆ˜ë¡œ ë°˜í™˜í•˜ì„¸ìš”.
5. **Recommended Workout:** ì˜¤ëŠ˜ ìˆ˜í–‰í•´ì•¼ í•  ì¶”ì²œ í›ˆë ¨ íƒ€ì…ì„ ì œì•ˆí•˜ì„¸ìš”.
Output Format (JSON Only):
{ "condition_score": 85, "training_status": "Ready to Race", "vo2max_estimate": 54, "coach_comment": "ì§€ì„±ë‹˜, ì´ë²ˆ ì£¼ TSS ëª©í‘œë¥¼ ê±°ì˜ ë‹¬ì„±í•˜ì…¨ë„¤ìš”! ì˜¤ëŠ˜ì€ ê°€ë²¼ìš´ ë¦¬ì»¤ë²„ë¦¬ë¡œ ì»¨ë””ì…˜ì„ ì¡°ì ˆí•˜ì„¸ìš”.", "recommended_workout": "Active Recovery (Z1)" }`;
    function isMobile() {
      var ua = navigator.userAgent || '';
      var isMobileUA = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(ua);
      var isTouchDevice = (navigator.maxTouchPoints && navigator.maxTouchPoints > 2) || ('ontouchstart' in window);
      var isBluefy = /Bluefy/i.test(ua) || (window.navigator && window.navigator.standalone === false && window.navigator.standalone !== undefined);
      return isMobileUA || isTouchDevice || isBluefy;
    }
    async function callGeminiCoach(userProfile, recentLogs) {
      var apiKey;
      try {
        apiKey = localStorage.getItem('geminiApiKey');
      } catch (e) {
        apiKey = null;
      }
      if (!apiKey) throw new Error('Gemini API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™˜ê²½ ì„¤ì •ì—ì„œ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      var prompt = (window.GEMINI_COACH_SYSTEM_PROMPT || '')
        .replace('{{userProfile}}', JSON.stringify(userProfile, null, 2))
        .replace('{{recentLogs}}', JSON.stringify(recentLogs || [], null, 2))
        .replace('{{userName}}', (userProfile && userProfile.name) || 'ì‚¬ìš©ì');
      var modelName = localStorage.getItem('geminiModelName') || 'gemini-2.5-flash';
      var apiVersion = localStorage.getItem('geminiApiVersion') || 'v1beta';
      var url = 'https://generativelanguage.googleapis.com/' + apiVersion + '/models/' + modelName + ':generateContent?key=' + apiKey;
      var body = { contents: [{ parts: [{ text: prompt }] }], generationConfig: { maxOutputTokens: 2048, temperature: 0.7, topP: 0.8, topK: 40 } };
      var timeoutMs = isMobile() ? 45000 : 25000;
      var lastErr = null;
      var hasAbortController = typeof AbortController !== 'undefined';
      for (var attempt = 0; attempt < 3; attempt++) {
        try {
          var controller = null;
          var timeoutId = null;
          var fetchOptions = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) };
          if (hasAbortController) {
            try {
              controller = new AbortController();
              timeoutId = setTimeout(function() { if (controller) controller.abort(); }, timeoutMs);
              fetchOptions.signal = controller.signal;
            } catch (e) {
              hasAbortController = false;
            }
          }
          var fetchPromise = fetch(url, fetchOptions).catch(function(fetchErr) {
            console.error('[callGeminiCoach] fetch ì‹¤íŒ¨ (ì‹œë„ ' + (attempt + 1) + '):', fetchErr);
            throw fetchErr;
          });
          var timeoutPromise = hasAbortController ? null : new Promise(function(resolve, reject) {
            timeoutId = setTimeout(function() { reject(new Error('ìš”ì²­ ì‹œê°„ ì´ˆê³¼')); }, timeoutMs);
          });
          var res;
          try {
            res = hasAbortController ? await fetchPromise : await Promise.race([fetchPromise, timeoutPromise]);
          } catch (fetchErr) {
            if (timeoutId) clearTimeout(timeoutId);
            throw fetchErr;
          }
          if (timeoutId) clearTimeout(timeoutId);
          
          if (!res.ok) {
            var errBody = await res.text();
            var errMsg = '';
            try {
              var ed = JSON.parse(errBody);
              errMsg = (ed.error && ed.error.message) || errBody;
            } catch (e2) { errMsg = errBody.substring(0, 200); }
            throw new Error('Gemini API ì˜¤ë¥˜ (' + res.status + '): ' + errMsg);
          }
          
          var data = await res.json();
          if (!data || !data.candidates || !Array.isArray(data.candidates) || data.candidates.length === 0) {
            throw new Error('Gemini API ì‘ë‹µì— candidatesê°€ ì—†ìŠµë‹ˆë‹¤.');
          }
          var candidate = data.candidates[0];
          if (candidate.finishReason === 'SAFETY') {
            throw new Error('Gemini APIê°€ ì•ˆì „ ì •ì±…ìœ¼ë¡œ ì‘ë‹µì„ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤.');
          }
          if (!candidate.content || !candidate.content.parts || !candidate.content.parts[0]) {
            throw new Error('Gemini API ì‘ë‹µì— content.partsê°€ ì—†ìŠµë‹ˆë‹¤.');
          }
          var text = (candidate.content.parts[0].text || '').trim();
          if (!text) throw new Error('Gemini API ì‘ë‹µì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');
          if (text.indexOf('```') === 0) {
            text = text.replace(/^```(?:json)?\s*/i, '').replace(/\s*```$/i, '');
          }
          var result = JSON.parse(text);
          return {
            condition_score: (typeof result.condition_score === 'number') ? Math.max(0, Math.min(100, result.condition_score)) : 50,
            training_status: result.training_status || 'Building Base',
            vo2max_estimate: (typeof result.vo2max_estimate === 'number') ? Math.max(20, Math.min(100, result.vo2max_estimate)) : 40,
            coach_comment: result.coach_comment || ((userProfile && userProfile.name) || 'ì‚¬ìš©ì') + 'ë‹˜, ì˜¤ëŠ˜ë„ í™”ì´íŒ…í•˜ì„¸ìš”!',
            recommended_workout: result.recommended_workout || 'Active Recovery (Z1)'
          };
        } catch (e) {
          lastErr = e;
          var errType = 'unknown';
          var errDetail = '';
          if (e && e.message) {
            errType = e.message;
            if (e.message.indexOf('Failed to fetch') !== -1 || e.message.indexOf('NetworkError') !== -1) {
              errType = 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜';
              errDetail = 'ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ê±°ë‚˜, ë°©í™”ë²½/ë³´ì•ˆ ì†Œí”„íŠ¸ì›¨ì–´ê°€ API ìš”ì²­ì„ ì°¨ë‹¨í–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
              if (window.parent && window.parent !== window) {
                errDetail += ' (iframe í™˜ê²½ì—ì„œëŠ” ì¼ë¶€ ë¸Œë¼ìš°ì €ì—ì„œ ì™¸ë¶€ API í˜¸ì¶œì´ ì œí•œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤)';
              }
            } else if (e.message.indexOf('CORS') !== -1 || e.message.indexOf('cross-origin') !== -1) {
              errType = 'CORS ì˜¤ë¥˜';
              errDetail = 'ë¸Œë¼ìš°ì € ë³´ì•ˆ ì •ì±…ìœ¼ë¡œ ì¸í•´ API í˜¸ì¶œì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.';
            } else if (e.message.indexOf('aborted') !== -1 || e.message.indexOf('ì‹œê°„ ì´ˆê³¼') !== -1) {
              errType = 'ìš”ì²­ ì‹œê°„ ì´ˆê³¼';
              errDetail = 'ë„¤íŠ¸ì›Œí¬ê°€ ëŠë¦¬ê±°ë‚˜ ì„œë²„ ì‘ë‹µì´ ì§€ì—°ë˜ê³  ìˆìŠµë‹ˆë‹¤.';
            }
          }
          if (attempt < 2) {
            console.warn('[callGeminiCoach] ì¬ì‹œë„ ' + (attempt + 1) + '/3:', errType, errDetail || '');
            await new Promise(function(r) { setTimeout(r, 2000); });
          }
        }
      }
      var errMsg = lastErr && lastErr.message ? lastErr.message : 'unknown';
      var errDisplay = errMsg;
      if (errMsg.indexOf('Failed to fetch') !== -1) {
        errDisplay = 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ê±°ë‚˜, ë°©í™”ë²½ì´ API ìš”ì²­ì„ ì°¨ë‹¨í–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
        if (window.parent && window.parent !== window) {
          errDisplay += ' (iframe í™˜ê²½ ì œí•œ ê°€ëŠ¥)';
        }
      }
      console.warn('[callGeminiCoach] AI ë¶„ì„ ì‹¤íŒ¨ (ì¬ì‹œë„ 3íšŒ í›„):', errMsg);
      if (lastErr && lastErr.stack) {
        console.error('[callGeminiCoach] ì˜¤ë¥˜ ìŠ¤íƒ:', lastErr.stack.substring(0, 500));
      }
      return {
        condition_score: 50,
        training_status: 'Building Base',
        vo2max_estimate: 40,
        coach_comment: ((userProfile && userProfile.name) || 'ì‚¬ìš©ì') + 'ë‹˜, ë°ì´í„° ë¶„ì„ ì¤‘ ì¼ì‹œì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
        recommended_workout: 'Active Recovery (Z1)',
        error_reason: errDisplay || errMsg
      };
    }
    window.callGeminiCoach = callGeminiCoach;
  </script>
  
  <style>
    /* ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¹€ - ì „ì²´(html/body) ë° .scrollbar-hide */
    html, body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar {
      display: none;
    }
    .scrollbar-hide {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .scrollbar-hide::-webkit-scrollbar {
      display: none;
    }
    
    /* Circular Progress Bar ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes progress {
      from {
        stroke-dashoffset: 283;
      }
    }
    
    .circular-progress {
      animation: progress 1s ease-out;
    }
    
    /* Skeleton UI ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes shimmer {
      0% {
        background-position: -1000px 0;
      }
      100% {
        background-position: 1000px 0;
      }
    }
    
    .skeleton {
      background: linear-gradient(
        90deg,
        #f0f0f0 0px,
        #e0e0e0 40px,
        #f0f0f0 80px
      );
      background-size: 1000px;
      animation: shimmer 2s infinite;
    }
  </style>
</head>
<body class="bg-gray-50 scrollbar-hide">
  <script>
    window.__dashboardUserFromParent = null;
    window.addEventListener('message', function (e) {
      try {
        if (e.data && e.data.type === 'DASHBOARD_USER' && e.data.user) {
          if (window.parent && window.parent !== window) {
            var origin = e.origin || '';
            var parentOrigin = window.location.origin || '';
            if (origin === parentOrigin || origin === '*' || parentOrigin === '') {
              window.__dashboardUserFromParent = e.data.user;
            }
          } else {
            window.__dashboardUserFromParent = e.data.user;
          }
        }
      } catch (err) {
        console.warn('[Dashboard] postMessage ì²˜ë¦¬ ì˜¤ë¥˜:', err);
      }
    });
  </script>
  <div id="dashboard-root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // í¬ì¸íŠ¸ í¬ë§·íŒ… ìœ í‹¸ë¦¬í‹° (ì •ìˆ˜, 1000 ì´ìƒì€ k í˜•ì‹)
    function formatPoints(points) {
      const num = Math.round(Number(points) || 0);
      if (num >= 1000) {
        const k = num / 1000;
        return k % 1 === 0 ? k + 'k' : k.toFixed(1) + 'k';
      }
      return num.toString();
    }
    
    // DashboardCard ì»´í¬ë„ŒíŠ¸
    function DashboardCard({ title, children, className = "" }) {
      return (
        <div className={`bg-white rounded-2xl p-4 shadow-sm border border-gray-100 ${className}`}>
          {title && (
            <h3 className="text-sm font-semibold text-gray-600 mb-3">{title}</h3>
          )}
          {children}
        </div>
      );
    }
    
    // Training Trend Chart ì»´í¬ë„ŒíŠ¸ (Chart.js ì‚¬ìš©)
    function TrainingTrendChart({ data }) {
      const chartRef = useRef(null);
      const chartInstanceRef = useRef(null);
      
      useEffect(() => {
        if (!data || data.length === 0) return;
        
        const ctx = chartRef.current?.getContext('2d');
        if (!ctx) return;
        
        // ê¸°ì¡´ ì°¨íŠ¸ê°€ ìˆìœ¼ë©´ ì œê±°
        if (chartInstanceRef.current) {
          chartInstanceRef.current.destroy();
        }
        
        // Chart.jsë¡œ ì°¨íŠ¸ ìƒì„±
        chartInstanceRef.current = new Chart(ctx, {
          type: 'line',
          data: {
            labels: data.map(d => d.date),
            datasets: [
              {
                label: 'Fitness',
                data: data.map(d => d.fitness),
                borderColor: '#3b82f6',
                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                tension: 0.4,
                fill: false,
                pointRadius: 4,
                pointBackgroundColor: '#3b82f6'
              },
              {
                label: 'Fatigue',
                data: data.map(d => d.fatigue),
                borderColor: '#ef4444',
                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                tension: 0.4,
                fill: false,
                pointRadius: 4,
                pointBackgroundColor: '#ef4444'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: {
                  usePointStyle: true,
                  padding: 15,
                  font: {
                    size: 12
                  }
                }
              },
              tooltip: {
                backgroundColor: 'white',
                borderColor: '#e5e7eb',
                borderWidth: 1,
                cornerRadius: 8,
                padding: 12,
                titleFont: {
                  size: 13,
                  weight: 'bold'
                },
                bodyFont: {
                  size: 12
                }
              }
            },
            scales: {
              x: {
                grid: {
                  display: true,
                  color: '#e5e7eb',
                  drawBorder: false
                },
                ticks: {
                  font: {
                    size: 11
                  },
                  color: '#6b7280'
                }
              },
              y: {
                grid: {
                  display: true,
                  color: '#e5e7eb',
                  drawBorder: false
                },
                ticks: {
                  font: {
                    size: 11
                  },
                  color: '#6b7280'
                },
                beginAtZero: true
              }
            }
          }
        });
        
        // ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ ì‹œ ì°¨íŠ¸ ì •ë¦¬
        return () => {
          if (chartInstanceRef.current) {
            chartInstanceRef.current.destroy();
            chartInstanceRef.current = null;
          }
        };
      }, [data]);
      
      if (!data || data.length === 0) {
        return (
          <DashboardCard title="í›ˆë ¨ íŠ¸ë Œë“œ (ìµœê·¼ 7ì¼)">
            <div className="h-[200px] flex items-center justify-center text-gray-400 text-sm">
              ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤
            </div>
          </DashboardCard>
        );
      }
      
      return (
        <DashboardCard title="í›ˆë ¨ íŠ¸ë Œë“œ (ìµœê·¼ 7ì¼)">
          <div className="h-[200px]">
            <canvas ref={chartRef}></canvas>
          </div>
        </DashboardCard>
      );
    }
    
    // Circular Progress ì»´í¬ë„ŒíŠ¸
    function CircularProgress({ value, max = 100, size = 120, strokeWidth = 8 }) {
      const percentage = Math.min((value / max) * 100, 100);
      const radius = (size - strokeWidth) / 2;
      const circumference = 2 * Math.PI * radius;
      const offset = circumference - (percentage / 100) * circumference;
      
      const getColor = () => {
        if (percentage >= 80) return '#10b981'; // green
        if (percentage >= 60) return '#3b82f6'; // blue
        if (percentage >= 40) return '#f59e0b'; // amber
        return '#ef4444'; // red
      };
      
      return (
        <div className="relative inline-flex items-center justify-center" style={{ width: size, height: size }}>
          <svg width={size} height={size} className="transform -rotate-90">
            {/* ë°°ê²½ ì› */}
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              stroke="#e5e7eb"
              strokeWidth={strokeWidth}
              fill="none"
            />
            {/* ì§„í–‰ ì› */}
            <circle
              cx={size / 2}
              cy={size / 2}
              r={radius}
              stroke={getColor()}
              strokeWidth={strokeWidth}
              fill="none"
              strokeDasharray={circumference}
              strokeDashoffset={offset}
              strokeLinecap="round"
              className="circular-progress transition-all duration-500"
            />
          </svg>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="text-center">
              <div className="text-3xl font-bold" style={{ color: getColor() }}>
                {Math.round(value)}
              </div>
              <div className="text-xs text-gray-500">ì </div>
            </div>
          </div>
        </div>
      );
    }
    
    // ë©”ì¸ Dashboard ì»´í¬ë„ŒíŠ¸
    function PerformanceDashboard() {
      const [userProfile, setUserProfile] = useState(null);
      const [coachData, setCoachData] = useState(null);
      const [recentLogs, setRecentLogs] = useState([]);
      const [logsLoaded, setLogsLoaded] = useState(false);
      const [loading, setLoading] = useState(true);
      const [stats, setStats] = useState({
        ftp: 0,
        wkg: 0,
        weight: 0,
        totalPoints: 0,
        currentPoints: 0,
        weeklyGoal: 0,
        weeklyProgress: 0
      });
      const [aiPairingStatus, setAiPairingStatus] = useState(false);
      const [stravaStatus, setStravaStatus] = useState({ connected: false, lastSync: null });
      const [fitnessData, setFitnessData] = useState([]);
      const [retryCoach, setRetryCoach] = useState(0);
      
      // ì‚¬ìš©ì í”„ë¡œí•„ ë¡œë“œ: URL/postMessage/localStorage ì¦‰ì‹œ í‘œì‹œ, FirestoreëŠ” ë‚˜ì¤‘ì— ë³´ê°•
      useEffect(() => {
        function applyProfileFromUser(u) {
          const id = u.id || u.uid;
          const name = u.name || u.displayName || 'ì‚¬ìš©ì';
          const ftp = Number(u.ftp) || 0;
          const weight = Number(u.weight) || 0;
          const wkg = weight > 0 ? (ftp / weight).toFixed(2) : 0;
          setUserProfile({
            id: id,
            name: name,
            ftp: ftp,
            weight: weight,
            grade: u.grade || '2',
            challenge: u.challenge || 'Fitness',
            acc_points: u.acc_points || 0,
            rem_points: u.rem_points || 0,
            ...u
          });
          var challenge = u.challenge || 'Fitness';
          var weeklyTarget = 100;
          if (typeof window.getWeeklyTargetTSS === 'function') {
            var targetInfo = window.getWeeklyTargetTSS(challenge);
            weeklyTarget = targetInfo.target;
          }
          setStats({
            ftp: ftp,
            wkg: parseFloat(wkg),
            weight: weight,
            totalPoints: Number(u.acc_points || 0),
            currentPoints: Number(u.rem_points || 0),
            weeklyGoal: weeklyTarget,
            weeklyProgress: 0
          });
          setStravaStatus({
            connected: !!(u.strava_refresh_token),
            lastSync: u.strava_last_sync || null
          });
        }
        
        function phase1Immediate() {
          let userId = null;
          let fullUser = null;
          try {
            var search = window.location.search || '';
            if (search && typeof URLSearchParams !== 'undefined') {
              const params = new URLSearchParams(search);
              userId = params.get('userId') || params.get('user_id') || null;
            } else if (search) {
              var match = search.match(/[?&](?:userId|user_id)=([^&]+)/);
              if (match) userId = decodeURIComponent(match[1]);
            }
            if (userId) console.log('[Dashboard] URLì—ì„œ ì‚¬ìš©ì ID ê°€ì ¸ì˜´:', userId);
          } catch (e) {
            console.warn('[Dashboard] URL íŒŒë¼ë¯¸í„° íŒŒì‹± ì‹¤íŒ¨:', e);
          }
          if (!userId && window.__dashboardUserFromParent && window.__dashboardUserFromParent.id) {
            fullUser = window.__dashboardUserFromParent;
            userId = fullUser.id;
            console.log('[Dashboard] postMessageì—ì„œ ì‚¬ìš©ì ê°€ì ¸ì˜´:', userId);
          }
          if (!fullUser) {
            try {
              const stored = localStorage.getItem('currentUser');
              if (stored) {
                const parsed = JSON.parse(stored);
                if (parsed && (parsed.id || parsed.uid)) {
                  fullUser = parsed;
                  userId = fullUser.id || fullUser.uid;
                  if (!userId) console.log('[Dashboard] localStorageì—ì„œ ì‚¬ìš©ì ê°€ì ¸ì˜´');
                }
              }
            } catch (e) {
              console.warn('[Dashboard] localStorage ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨:', e);
            }
          }
          if (!userId && window.parent && window.parent !== window) {
            try {
              const auth = window.parent.auth || window.parent.window?.auth;
              const cu = auth && auth.currentUser;
              if (cu && cu.uid) {
                userId = cu.uid;
                console.log('[Dashboard] ë¶€ëª¨ ì°½ authì—ì„œ ì‚¬ìš©ì ID ê°€ì ¸ì˜´:', userId);
              }
            } catch (e) {}
          }
          if (!userId && window.auth) {
            try {
              const cu = window.auth.currentUser;
              if (cu && cu.uid) {
                userId = cu.uid;
                console.log('[Dashboard] í˜„ì¬ ì°½ authì—ì„œ ì‚¬ìš©ì ID ê°€ì ¸ì˜´:', userId);
              }
            } catch (e) {}
          }
          if (!userId) {
            console.warn('[Dashboard] ì‚¬ìš©ì IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            setUserProfile({ id: '', name: 'ì‚¬ìš©ì ì„ íƒ í•„ìš”', ftp: 0, weight: 0, grade: '2', acc_points: 0, rem_points: 0 });
            setLoading(false);
            return null;
          }
          if (fullUser) {
            applyProfileFromUser(fullUser);
            setLoading(false);
          } else {
            applyProfileFromUser({ id: userId, name: 'ì‚¬ìš©ì', ftp: 0, weight: 0 });
            setLoading(false);
          }
          return userId;
        }
        
        async function phase2Firestore(userId) {
          let firestore = window.firestore;
          if (window.parent && window.parent !== window) {
            try {
              firestore = window.parent.firestore || (window.parent.window && window.parent.window.firestore);
            } catch (e) {}
          }
          if (!firestore || !userId) return;
          try {
            const userDoc = await firestore.collection('users').doc(userId).get();
            if (!userDoc.exists) return;
            const userData = userDoc.data();
            applyProfileFromUser({ id: userId, ...userData });
          } catch (e) {
            console.warn('[Dashboard] Firestore í”„ë¡œí•„ ë³´ê°• ì‹¤íŒ¨:', e);
          }
        }
        
        const uid = phase1Immediate();
        
        const onParentUser = function (e) {
          try {
            if (e.data && e.data.type === 'DASHBOARD_USER' && e.data.user) {
              if (window.parent && window.parent !== window) {
                var origin = e.origin || '';
                var parentOrigin = window.location.origin || '';
                if (origin === parentOrigin || origin === '*' || parentOrigin === '') {
                  applyProfileFromUser(e.data.user);
                }
              } else {
                applyProfileFromUser(e.data.user);
              }
            }
          } catch (err) {
            console.warn('[Dashboard] postMessage ì²˜ë¦¬ ì˜¤ë¥˜:', err);
          }
        };
        window.addEventListener('message', onParentUser);
        
        let firestoreCheck = setInterval(function () {
          const fs = window.firestore || (window.parent && window.parent !== window && (window.parent.firestore || (window.parent.window && window.parent.window.firestore)));
          if (fs && uid) {
            clearInterval(firestoreCheck);
            phase2Firestore(uid);
          }
        }, 200);
        const t = setTimeout(function () {
          clearInterval(firestoreCheck);
          if (uid) phase2Firestore(uid);
        }, 8000);
        return function () {
          window.removeEventListener('message', onParentUser);
          clearInterval(firestoreCheck);
          clearTimeout(t);
        };
      }, []);
      
      // ìµœê·¼ í›ˆë ¨ ë¡œê·¸ ë¡œë“œ (ì£¼ê°„ ëª©í‘œÂ·í›ˆë ¨ íŠ¸ë Œë“œìš©) â€” íœ´ëŒ€í° iframeì—ì„œ Firestore ì§€ì—° ëŒ€ê¸° + ì¬ì‹œë„
      useEffect(() => {
        var retryCount = 0;
        var maxRetries = 3;
        var retryDelay = 2000;
        
        async function loadRecentLogs() {
          if (!userProfile || !userProfile.id) return;
          
          function getFirestore() {
            var fs = window.firestore;
            if (window.parent && window.parent !== window) {
              try {
                fs = window.parent.firestore || (window.parent.window && window.parent.window.firestore) || fs;
              } catch (e) {}
            }
            return fs;
          }
          
          var firestore = getFirestore();
          if (!firestore) {
            var deadline = Date.now() + 10000;
            while (!firestore && Date.now() < deadline) {
              await new Promise(function(r) { setTimeout(r, 200); });
              firestore = getFirestore();
            }
          }
          if (!firestore) {
            if (retryCount < maxRetries) {
              retryCount++;
              console.warn('[Dashboard] í›ˆë ¨ ë¡œê·¸: Firestore ë¯¸ì¤€ë¹„, ì¬ì‹œë„ ' + retryCount + '/' + maxRetries);
              setTimeout(loadRecentLogs, retryDelay);
              return;
            }
            console.warn('[Dashboard] í›ˆë ¨ ë¡œê·¸: Firestore ë¯¸ì¤€ë¹„(ìµœì¢… íƒ€ì„ì•„ì›ƒ). ì£¼ê°„ ëª©í‘œ/íŠ¸ë Œë“œ ë¯¸í‘œì‹œ.');
            return;
          }
          
          try {
            var thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
            var dateStr = thirtyDaysAgo.toISOString().split('T')[0];
            var logs = [];
            
            try {
              var userLogsRef = firestore.collection('users').doc(userProfile.id).collection('logs');
              var logsSnapshot;
              try {
                logsSnapshot = await userLogsRef.orderBy('date', 'desc').limit(50).get();
              } catch (indexErr) {
                logsSnapshot = await userLogsRef.limit(100).get();
              }
              var raw = [];
              logsSnapshot.docs.forEach(function(doc) {
                var d = doc.data();
                if ((d.source === 'strava' || !d.source) && d.date && d.date >= dateStr) {
                  raw.push({ id: doc.id, ...d });
                }
              });
              raw.sort(function(a, b) { return (b.date || '').localeCompare(a.date || ''); });
              logs = raw.slice(0, 30);
              setRecentLogs(logs);
              setLogsLoaded(true);
              console.log('[Dashboard] í›ˆë ¨ ë¡œê·¸ ë¡œë“œ ì„±ê³µ:', logs.length + 'ê°œ');
            } catch (queryErr) {
              console.warn('[Dashboard] í›ˆë ¨ ë¡œê·¸ ì¡°íšŒ ì‹¤íŒ¨:', queryErr);
              if (retryCount < maxRetries) {
                retryCount++;
                console.warn('[Dashboard] í›ˆë ¨ ë¡œê·¸ ì¬ì‹œë„ ' + retryCount + '/' + maxRetries);
                setTimeout(loadRecentLogs, retryDelay);
                return;
              }
              setRecentLogs([]);
              setLogsLoaded(true);
            }
            
            var totalTss = logs.reduce(function(s, log) { return s + (Number(log.tss) || 0); }, 0);
            var totalTssRounded = Math.round(totalTss);
            var challenge = userProfile.challenge || 'Fitness';
            var weeklyTarget = 100;
            if (typeof window.getWeeklyTargetTSS === 'function') {
              var targetInfo = window.getWeeklyTargetTSS(challenge);
              weeklyTarget = targetInfo.target;
            }
            setStats(function(prev) {
              return { ...prev, weeklyGoal: weeklyTarget, weeklyProgress: Math.min(totalTssRounded, 9999) };
            });
            
            var last7 = logs.slice(0, 7).reverse();
            var chartData = last7.map(function(log) {
              return {
                date: new Date(log.date).toLocaleDateString('ko-KR', { month: 'short', day: 'numeric' }),
                fitness: Number(log.tss) || 0,
                fatigue: (Number(log.tss) || 0) * 0.7
              };
            });
            setFitnessData(chartData);
          } catch (e) {
            console.error('[Dashboard] í›ˆë ¨ ë¡œê·¸ ë¡œë“œ ì˜¤ë¥˜:', e);
            if (retryCount < maxRetries) {
              retryCount++;
              setTimeout(loadRecentLogs, retryDelay);
            }
          }
        }
        
        if (userProfile && userProfile.id) {
          loadRecentLogs();
        }
      }, [userProfile]);
      
      // Gemini AI ì½”ì¹˜ ë¶„ì„ í˜¸ì¶œ (ë¡œê·¸ ë¡œë“œ ì™„ë£Œ í›„ ìë™ ì¬í˜¸ì¶œ)
      useEffect(() => {
        async function fetchCoachAnalysis() {
          if (!userProfile) {
            setLoading(false);
            return;
          }
          
          var logs = Array.isArray(recentLogs) ? recentLogs : [];
          var logsHash = logs.length > 0 ? logs.length + '_' + (logs[0] && logs[0].date || '') + '_' + (logs[logs.length - 1] && logs[logs.length - 1].date || '') : 'empty';
          var cacheKey = 'coach_analysis_' + userProfile.id + '_' + logsHash;
          
          try {
            var useCache = false;
            var skipCache = retryCoach > 0;
            if (!skipCache) {
              try {
                var cached = localStorage.getItem(cacheKey);
                if (cached) {
                  var parsed = JSON.parse(cached);
                  var oneHour = 60 * 60 * 1000;
                  if (parsed.data && parsed.timestamp && (Date.now() - parsed.timestamp < oneHour) && !(parsed.data && parsed.data.error_reason)) {
                    setCoachData(parsed.data);
                    useCache = true;
                  }
                }
              } catch (e) {
                useCache = false;
              }
            }
            if (useCache) {
              setAiPairingStatus(true);
              setLoading(false);
              return;
            }
            if (skipCache) setLoading(true);
            
            if (typeof window.callGeminiCoach === 'function') {
              var analysis = await window.callGeminiCoach(userProfile, logs);
              var isFallback = !analysis || (analysis.coach_comment && analysis.coach_comment.indexOf('ì¼ì‹œì ì¸ ì˜¤ë¥˜') !== -1) || !!(analysis && analysis.error_reason);
              setCoachData(analysis);
              setAiPairingStatus(!isFallback);
              if (!isFallback && analysis && !analysis.error_reason) {
                try {
                  localStorage.setItem(cacheKey, JSON.stringify({ data: analysis, timestamp: Date.now() }));
                } catch (e) {}
              }
            }
          } catch (error) {
            var errMsg = (error && error.message) ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
            console.error('AI ì½”ì¹˜ ë¶„ì„ ì˜¤ë¥˜:', error);
            setAiPairingStatus(false);
            setCoachData({
              condition_score: 50,
              training_status: 'Building Base',
              vo2max_estimate: 40,
              coach_comment: (userProfile && userProfile.name || 'ì‚¬ìš©ì') + 'ë‹˜, ë°ì´í„° ë¶„ì„ ì¤‘ ì¼ì‹œì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
              recommended_workout: 'Active Recovery (Z1)',
              error_reason: errMsg
            });
          } finally {
            setLoading(false);
          }
        }
        
        if (userProfile) {
          fetchCoachAnalysis();
        } else {
          setLoading(false);
        }
      }, [userProfile, recentLogs, retryCoach, logsLoaded]);
      
      // ë“±ê¸‰ ë±ƒì§€ í…ìŠ¤íŠ¸
      const getGradeBadge = (grade) => {
        const badges = {
          '1': 'ğŸ’ Diamond',
          '2': 'â­ Member',
          '3': 'ğŸ‘‘ Admin'
        };
        return badges[grade] || 'â­ Member';
      };
      
      if (loading) {
        return (
          <div className="max-w-[480px] mx-auto min-h-screen bg-gray-50 flex items-center justify-center">
            <div className="text-center">
              <div className="skeleton w-32 h-32 rounded-full mx-auto mb-4"></div>
              <div className="skeleton w-48 h-6 mx-auto mb-2"></div>
              <div className="skeleton w-64 h-4 mx-auto"></div>
            </div>
          </div>
        );
      }
      
      return (
        <div className="max-w-[480px] mx-auto min-h-screen bg-gray-50 scrollbar-hide">
          {/* Header */}
          <header className="sticky top-0 z-10 bg-white/80 backdrop-blur-md border-b border-gray-200 px-4 py-3">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-full bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center text-white font-bold">
                  {userProfile?.name?.charAt(0) || 'U'}
                </div>
                <div>
                  <div className="font-semibold text-gray-900">{userProfile?.name || 'ì‚¬ìš©ì'}</div>
                  <div className="text-xs text-gray-500">{getGradeBadge(userProfile?.grade)}</div>
                </div>
              </div>
              <button
                className="p-2 rounded-lg hover:bg-gray-100 active:opacity-80 transition-all"
                onClick={() => {
                  // í”„ë¡œí•„ í¸ì§‘ ëª¨ë‹¬ ì—´ê¸° (ì¶”í›„ êµ¬í˜„)
                  alert('í”„ë¡œí•„ í¸ì§‘ ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
                }}
              >
                <svg className="w-6 h-6 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                </svg>
              </button>
            </div>
          </header>
          
          <div className="px-4 py-6 space-y-6 pb-24">
            {/* Status Control Center */}
            <div className="flex gap-3 overflow-x-auto scrollbar-hide pb-2">
              <DashboardCard className="min-w-[140px]">
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${aiPairingStatus ? 'bg-green-500' : 'bg-gray-300'}`}></div>
                  <span className="text-sm text-gray-700">AI í˜ì–´ë§</span>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {aiPairingStatus ? 'ì—°ê²°ë¨' : 'ì—°ê²° ëŒ€ê¸°'}
                </div>
              </DashboardCard>
              
              <DashboardCard className="min-w-[140px]">
                <div className="flex items-center gap-2">
                  <div className={`w-3 h-3 rounded-full ${stravaStatus.connected ? 'bg-green-500' : 'bg-gray-300'}`}></div>
                  <span className="text-sm text-gray-700">Strava</span>
                </div>
                <div className="text-xs text-gray-500 mt-1">
                  {stravaStatus.connected 
                    ? stravaStatus.lastSync 
                      ? `ë™ê¸°í™”: ${new Date(stravaStatus.lastSync).toLocaleDateString('ko-KR')}`
                      : 'ì—°ê²°ë¨'
                    : 'ì—°ê²° ëŒ€ê¸°'}
                </div>
              </DashboardCard>
            </div>
            
            {/* Gemini Coach Insight */}
            <DashboardCard className="bg-gradient-to-br from-blue-50 to-purple-50 border-2 border-blue-200">
              {coachData ? (
                <>
                  <div className="flex items-center justify-center mb-4">
                    <CircularProgress value={coachData.condition_score} />
                  </div>
                  <div className="text-center mb-3">
                    <div className="text-lg font-bold text-gray-900 mb-1">
                      {coachData.training_status}
                    </div>
                    <div className="text-sm text-gray-600">
                      VOâ‚‚max ì¶”ì •: {coachData.vo2max_estimate} ml/kg/min
                    </div>
                  </div>
                  <div className="bg-white/80 rounded-xl p-4 mb-3">
                    <p className="text-sm text-gray-800 leading-relaxed">
                      {coachData.coach_comment}
                    </p>
                    {coachData.error_reason && (
                      <div className="mt-3 pt-3 border-t border-amber-200 space-y-1">
                        <p className="text-xs text-amber-700">ì›ì¸: {coachData.error_reason}</p>
                        {(coachData.error_reason.indexOf('API í‚¤') !== -1 || coachData.error_reason.indexOf('geminiApiKey') !== -1) && (
                          <p className="text-xs text-gray-600">í™˜ê²½ ì„¤ì •ì—ì„œ Gemini API í‚¤ë¥¼ ì…ë ¥í•œ ë’¤ &quot;ë‹¤ì‹œ ë¶„ì„&quot;ì„ ëˆŒëŸ¬ ì£¼ì„¸ìš”.</p>
                        )}
                        {(coachData.error_reason.indexOf('ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜') !== -1 || coachData.error_reason.indexOf('Failed to fetch') !== -1) && (
                          <p className="text-xs text-gray-600">ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•˜ê±°ë‚˜, ë°©í™”ë²½/ë³´ì•ˆ ì†Œí”„íŠ¸ì›¨ì–´ê°€ API ìš”ì²­ì„ ì°¨ë‹¨í•˜ì§€ ì•ŠëŠ”ì§€ í™•ì¸í•´ ì£¼ì„¸ìš”.</p>
                        )}
                      </div>
                    )}
                  </div>
                  <div className="text-center flex flex-wrap items-center justify-center gap-2">
                    <span className="inline-block bg-blue-100 text-blue-800 text-xs font-semibold px-3 py-1 rounded-full">
                      ì¶”ì²œ: {coachData.recommended_workout}
                    </span>
                    {coachData.error_reason && (
                      <button
                        type="button"
                        onClick={() => {
                          try {
                            localStorage.removeItem('coach_analysis_' + (userProfile && userProfile.id));
                          } catch (e) {}
                          setRetryCoach(function(c) { return c + 1; });
                        }}
                        className="inline-block bg-amber-100 text-amber-800 text-xs font-semibold px-3 py-1.5 rounded-full hover:bg-amber-200 active:opacity-80 min-h-[44px]"
                      >
                        ë‹¤ì‹œ ë¶„ì„
                      </button>
                    )}
                  </div>
                </>
              ) : (
                <div className="text-center py-8">
                  <div className="skeleton w-24 h-24 rounded-full mx-auto mb-4"></div>
                  <div className="skeleton w-32 h-4 mx-auto mb-2"></div>
                  <div className="skeleton w-48 h-3 mx-auto"></div>
                </div>
              )}
            </DashboardCard>
            
            {/* Stats Grid (2x2) */}
            <div className="grid grid-cols-2 gap-3">
              {/* Power Card */}
              <DashboardCard title="íŒŒì›Œ">
                <div className="text-2xl font-bold text-gray-900 mb-1">{stats.ftp}W</div>
                <div className="text-sm text-gray-600">{stats.wkg} W/kg</div>
              </DashboardCard>
              
              {/* Rewards/Points Card */}
              <DashboardCard title="í¬ì¸íŠ¸">
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-2xl">ğŸ’°</span>
                  <div>
                    <div className="text-lg font-bold text-gray-900">{formatPoints(stats.currentPoints)}</div>
                    <div className="text-xs text-gray-500">ë³´ìœ </div>
                  </div>
                </div>
                <div className="text-xs text-gray-600 border-t border-gray-100 pt-2 mt-2">
                  ëˆ„ì : {formatPoints(stats.totalPoints)}pt
                </div>
              </DashboardCard>
              
              {/* Physique Card */}
              <DashboardCard title="ì²´í˜•">
                <div className="text-2xl font-bold text-gray-900 mb-1">{stats.weight}kg</div>
                <div className="text-sm text-gray-600">ì²´ì¤‘</div>
              </DashboardCard>
              
              {/* Progress Card */}
              <DashboardCard title="ì£¼ê°„ ëª©í‘œ">
                <div className="relative w-16 h-16 mx-auto mb-2">
                  <svg className="w-16 h-16 transform -rotate-90">
                    <circle
                      cx="32"
                      cy="32"
                      r="28"
                      stroke="#e5e7eb"
                      strokeWidth="6"
                      fill="none"
                    />
                    <circle
                      cx="32"
                      cy="32"
                      r="28"
                      stroke="#3b82f6"
                      strokeWidth="6"
                      fill="none"
                      strokeDasharray={`${2 * Math.PI * 28}`}
                      strokeDashoffset={`${2 * Math.PI * 28 * (1 - Math.min(stats.weeklyProgress / (stats.weeklyGoal || 100), 1))}`}
                      strokeLinecap="round"
                    />
                  </svg>
                  <div className="absolute inset-0 flex items-center justify-center">
                    <span className="text-sm font-bold text-gray-900">
                      {Math.min(Math.round((stats.weeklyProgress / (stats.weeklyGoal || 100)) * 100), 100)}%
                    </span>
                  </div>
                </div>
                <div className="text-xs text-gray-600 text-center">
                  {stats.weeklyProgress}/{stats.weeklyGoal || 100} TSS
                </div>
              </DashboardCard>
            </div>
            
            {/* Training Trend Chart */}
            <TrainingTrendChart data={fitnessData} />
          </div>
        </div>
      );
    }
    
    // React ì•± ë Œë”ë§ (React 18 í˜¸í™˜)
    const rootElement = document.getElementById('dashboard-root');
    if (ReactDOM.createRoot) {
      // React 18+
      const root = ReactDOM.createRoot(rootElement);
      root.render(<PerformanceDashboard />);
    } else {
      // React 17 ì´í•˜
      ReactDOM.render(<PerformanceDashboard />, rootElement);
    }
  </script>
</body>
</html>
